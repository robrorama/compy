# -*- coding: utf-8 -*-
"""ok_so.many_things_to_look_into.megaSectors_May_29_2024_V10_new_lrc_plots.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1E59i0jk4qcSlmmdkM6rPlCihOn66uZ68
"""

# MADE ALL OF THE BLOCKS ABLE TO use the caching but there are some that belong over in the stock analysis page
# and need to add the matrix for all of the correlations to be added ... maybe too the heat map for the whole market like finviz ?
#@title : Install needed libraries :
#!pip install yfinance
#!pip install mplfinance

#Simplified Version
ticker='spy'
#@title Plot Linear Regression Channel
import yfinance as yf
import pandas as pd
import plotly.graph_objs as go
from scipy.stats import linregress
from datetime import datetime
import os

def download_data(ticker, period):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")
    return df

def add_linear_regression_bands(df):
    df_numeric_index = pd.to_numeric(df.index)
    slope, intercept, _, _, _ = linregress(df_numeric_index, df['Close'])
    df['Linear_Reg'] = intercept + slope * df_numeric_index
    df['Residuals'] = df['Close'] - df['Linear_Reg']
    residuals_std = df['Residuals'].std()

    desired_values = [.5, 1, 1.25, 1.5, 1.75, 2, 2.25, 3, 4]

    for i, num_std in enumerate(desired_values):
        df[f'Reg_High_{i+1}std'] = df['Linear_Reg'] + residuals_std * num_std
        df[f'Reg_Low_{i+1}std'] = df['Linear_Reg'] - residuals_std * num_std

    return df

def plot_data(df, title):
    fig = go.Figure()

    # Define desired_values within the plot_data function
    desired_values = [.5, 1, 1.25, 1.5, 1.75, 2, 2.25, 3, 4]


    fig.add_trace(go.Candlestick(x=df.index, open=df['Open'], high=df['High'], low=df['Low'], close=df['Close'], name='Market Data'))

    fig.add_trace(go.Scatter(x=df.index, y=df['Linear_Reg'], line=dict(color='blue', width=2), name='Linear Regression'))
    colors = ['grey', 'green', 'orange', 'red', 'purple', 'brown', 'pink', 'gray', 'blue']  # Add more colors as needed
    for i, num_std in enumerate(desired_values):
        fig.add_trace(go.Scatter(
            x=df.index,
            y=df[f'Reg_High_{i+1}std'],
            line=dict(color=colors[i], width=1, dash='dot'),
            name=f'Reg High {num_std} std'
        ))
        fig.add_trace(go.Scatter(
            x=df.index,
            y=df[f'Reg_Low_{i+1}std'],
            line=dict(color=colors[i], width=1, dash='dot'),
            name=f'Reg Low {num_std} std'
        ))

    fig.update_layout(title=title, xaxis_title='Date', yaxis_title='Price', height=800, width=1200)
    fig.show()

# Example usage:
#ticker = "NKE"  # Replace with desired ticker
ticker_data = download_data(ticker, period="1y")
ticker_data = add_linear_regression_bands(ticker_data)

# Plot data with technical indicators
plot_data(ticker_data, title=f"{ticker} Linear Regression Channel and CandleSticks")

# @title Plot Linear Regression Channel
import yfinance as yf
import pandas as pd
import plotly.graph_objs as go
from scipy.stats import linregress
from datetime import datetime
import os

def download_data(ticker, period):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")
    return df

def add_linear_regression_bands(df):
    df['Pct_Change'] = df['Close'].pct_change() * 100
    df = df.dropna().reset_index(drop=True)

    df_numeric_index = pd.to_numeric(df.index)
    slope, intercept, _, _, _ = linregress(df_numeric_index, df['Pct_Change'])
    df.loc[:, 'Linear_Reg'] = intercept + slope * df_numeric_index
    df.loc[:, 'Residuals'] = df['Pct_Change'] - df['Linear_Reg']
    residuals_std = df['Residuals'].std()

    desired_values = [.5, 1, 1.25, 1.5, 1.75, 2, 2.25, 3, 4]

    for i, num_std in enumerate(desired_values):
        df.loc[:, f'Reg_High_{i+1}std'] = df['Linear_Reg'] + residuals_std * num_std
        df.loc[:, f'Reg_Low_{i+1}std'] = df['Linear_Reg'] - residuals_std * num_std

    return df

def plot_data(df, title):
    fig = go.Figure()

    # Define desired_values within the plot_data function
    desired_values = [.5, 1, 1.25, 1.5, 1.75, 2, 2.25, 3, 4]

    fig.add_trace(go.Scatter(x=df.index, y=df['Pct_Change'], mode='lines', name='Percentage Change'))

    fig.add_trace(go.Scatter(x=df.index, y=df['Linear_Reg'], line=dict(color='blue', width=2), name='Linear Regression'))
    colors = ['grey', 'green', 'orange', 'red', 'purple', 'brown', 'pink', 'gray', 'blue']  # Add more colors as needed
    for i, num_std in enumerate(desired_values):
        fig.add_trace(go.Scatter(
            x=df.index,
            y=df[f'Reg_High_{i+1}std'],
            line=dict(color=colors[i], width=1, dash='dot'),
            name=f'Reg High {num_std} std'
        ))
        fig.add_trace(go.Scatter(
            x=df.index,
            y=df[f'Reg_Low_{i+1}std'],
            line=dict(color=colors[i], width=1, dash='dot'),
            name=f'Reg Low {num_std} std'
        ))

    fig.update_layout(title=title, xaxis_title='Date', yaxis_title='Percentage Change', height=800, width=1200)
    fig.show()

# Example usage:
# ticker = "NKE"  # Replace with desired ticker
ticker_data = download_data(ticker, period="1y")
ticker_data = add_linear_regression_bands(ticker_data)

# Plot data with technical indicators
plot_data(ticker_data, title=f"{ticker} Linear Regression Channel and Percentage Change")

import yfinance as yf
import pandas as pd
import plotly.graph_objs as go
from scipy.stats import linregress
from datetime import datetime
import os

def download_data(ticker, period):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")
    return df

def add_linear_regression_bands(df):
    df['Pct_Change'] = df['Close'].pct_change() * 100
    df = df.dropna().reset_index(drop=True)

    df_numeric_index = pd.to_numeric(df.index)
    slope, intercept, _, _, _ = linregress(df_numeric_index, df['Pct_Change'])
    df.loc[:, 'Linear_Reg'] = intercept + slope * df_numeric_index
    df.loc[:, 'Residuals'] = df['Pct_Change'] - df['Linear_Reg']
    residuals_std = df['Residuals'].std()

    desired_values = [.5, 1, 1.25, 1.5, 1.75, 2, 2.25, 3, 4]

    for i, num_std in enumerate(desired_values):
        df.loc[:, f'Reg_High_{i+1}std'] = df['Linear_Reg'] + residuals_std * num_std
        df.loc[:, f'Reg_Low_{i+1}std'] = df['Linear_Reg'] - residuals_std * num_std

    return df

def plot_data(df, title):
    fig = go.Figure()

    # Define desired_values within the plot_data function
    desired_values = [.5, 1, 1.25, 1.5, 1.75, 2, 2.25, 3, 4]

    fig.add_trace(go.Scatter(x=df.index, y=df['Pct_Change'], mode='lines', name='Percentage Change'))

    fig.add_trace(go.Scatter(x=df.index, y=df['Linear_Reg'], line=dict(color='blue', width=2), name='Linear Regression'))
    colors = ['grey', 'green', 'orange', 'red', 'purple', 'brown', 'pink', 'gray', 'blue']  # Add more colors as needed
    for i, num_std in enumerate(desired_values):
        fig.add_trace(go.Scatter(
            x=df.index,
            y=df[f'Reg_High_{i+1}std'],
            line=dict(color=colors[i], width=1, dash='dot'),
            name=f'Reg High {num_std} std'
        ))
        fig.add_trace(go.Scatter(
            x=df.index,
            y=df[f'Reg_Low_{i+1}std'],
            line=dict(color=colors[i], width=1, dash='dot'),
            name=f'Reg Low {num_std} std'
        ))

    fig.update_layout(title=title, xaxis_title='Date', yaxis_title='Percentage Change', height=800, width=1200)
    fig.show()

def calculate_statistics(df):
    df['Next_Day_Change'] = df['Pct_Change'].shift(-1)
    df['Direction'] = df['Pct_Change'] > 0
    df['Next_Day_Direction'] = df['Next_Day_Change'] > 0

    # Probability of going up or down based on the previous day's move
    prob_up_after_up = len(df[(df['Direction'] == True) & (df['Next_Day_Direction'] == True)]) / len(df[df['Direction'] == True])
    prob_down_after_up = 1 - prob_up_after_up

    prob_down_after_down = len(df[(df['Direction'] == False) & (df['Next_Day_Direction'] == False)]) / len(df[df['Direction'] == False])
    prob_up_after_down = 1 - prob_down_after_down

    # Probability of going up or down based on touching standard deviation bands
    touched_high_band = df['Pct_Change'] >= df['Reg_High_1std']
    touched_low_band = df['Pct_Change'] <= df['Reg_Low_1std']

    prob_up_after_high_band = len(df[touched_high_band & (df['Next_Day_Direction'] == True)]) / len(df[touched_high_band])
    prob_down_after_high_band = 1 - prob_up_after_high_band

    prob_down_after_low_band = len(df[touched_low_band & (df['Next_Day_Direction'] == False)]) / len(df[touched_low_band])
    prob_up_after_low_band = 1 - prob_down_after_low_band

    # Probability based on consecutive days
    df['Streak'] = df['Direction'].groupby((df['Direction'] != df['Direction'].shift()).cumsum()).cumcount() + 1
    prob_up_after_streak_up = len(df[(df['Streak'] >= 2) & (df['Direction'] == True) & (df['Next_Day_Direction'] == True)]) / len(df[(df['Streak'] >= 2) & (df['Direction'] == True)])
    prob_down_after_streak_down = len(df[(df['Streak'] >= 2) & (df['Direction'] == False) & (df['Next_Day_Direction'] == False)]) / len(df[(df['Streak'] >= 2) & (df['Direction'] == False)])

    stats = {
        "Probability of Up after Up": prob_up_after_up,
        "Probability of Down after Up": prob_down_after_up,
        "Probability of Down after Down": prob_down_after_down,
        "Probability of Up after Down": prob_up_after_down,
        "Probability of Up after High Band": prob_up_after_high_band,
        "Probability of Down after High Band": prob_down_after_high_band,
        "Probability of Down after Low Band": prob_down_after_low_band,
        "Probability of Up after Low Band": prob_up_after_low_band,
        "Probability of Up after Streak of Up Days": prob_up_after_streak_up,
        "Probability of Down after Streak of Down Days": prob_down_after_streak_down
    }

    return stats

# Example usage:
#ticker = "AAPL"  # Replace with desired ticker
ticker_data = download_data(ticker, period="1y")
ticker_data = add_linear_regression_bands(ticker_data)
plot_data(ticker_data, title=f"{ticker} Linear Regression Channel and Percentage Change")

# Calculate and display statistics
stats = calculate_statistics(ticker_data)
for key, value in stats.items():
    print(f"{key}: {value:.2%}")

import yfinance as yf
import pandas as pd
import plotly.graph_objs as go
from scipy.stats import linregress
from datetime import datetime
import os

def download_data(ticker, period):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")
    return df

def add_linear_regression_bands(df):
    df['Pct_Change'] = df['Close'].pct_change() * 100
    df = df.dropna().reset_index(drop=True)

    df_numeric_index = pd.to_numeric(df.index)
    slope, intercept, _, _, _ = linregress(df_numeric_index, df['Pct_Change'])
    df.loc[:, 'Linear_Reg'] = intercept + slope * df_numeric_index
    df.loc[:, 'Residuals'] = df['Pct_Change'] - df['Linear_Reg']
    residuals_std = df['Residuals'].std()

    desired_values = [.5, 1, 1.25, 1.5, 1.75, 2, 2.25, 3, 4]

    for i, num_std in enumerate(desired_values):
        df.loc[:, f'Reg_High_{i+1}std'] = df['Linear_Reg'] + residuals_std * num_std
        df.loc[:, f'Reg_Low_{i+1}std'] = df['Linear_Reg'] - residuals_std * num_std

    return df

def plot_data(df, title):
    fig = go.Figure()

    # Define desired_values within the plot_data function
    desired_values = [.5, 1, 1.25, 1.5, 1.75, 2, 2.25, 3, 4]

    fig.add_trace(go.Scatter(x=df.index, y=df['Pct_Change'], mode='lines', name='Percentage Change'))

    fig.add_trace(go.Scatter(x=df.index, y=df['Linear_Reg'], line=dict(color='blue', width=2), name='Linear Regression'))
    colors = ['grey', 'green', 'orange', 'red', 'purple', 'brown', 'pink', 'gray', 'blue']  # Add more colors as needed
    for i, num_std in enumerate(desired_values):
        fig.add_trace(go.Scatter(
            x=df.index,
            y=df[f'Reg_High_{i+1}std'],
            line=dict(color=colors[i], width=1, dash='dot'),
            name=f'Reg High {num_std} std'
        ))
        fig.add_trace(go.Scatter(
            x=df.index,
            y=df[f'Reg_Low_{i+1}std'],
            line=dict(color=colors[i], width=1, dash='dot'),
            name=f'Reg Low {num_std} std'
        ))

    fig.update_layout(title=title, xaxis_title='Date', yaxis_title='Percentage Change', height=800, width=1200)
    fig.show()

def calculate_statistics(df):
    df['Next_Day_Change'] = df['Pct_Change'].shift(-1)
    df['Direction'] = df['Pct_Change'] > 0
    df['Next_Day_Direction'] = df['Next_Day_Change'] > 0

    # Probability of going up or down based on the previous day's move
    prob_up_after_up = len(df[(df['Direction'] == True) & (df['Next_Day_Direction'] == True)]) / len(df[df['Direction'] == True])
    prob_down_after_up = 1 - prob_up_after_up

    prob_down_after_down = len(df[(df['Direction'] == False) & (df['Next_Day_Direction'] == False)]) / len(df[df['Direction'] == False])
    prob_up_after_down = 1 - prob_down_after_down

    # Probability of going up or down based on touching standard deviation bands
    touched_high_band = df['Pct_Change'] >= df['Reg_High_1std']
    touched_low_band = df['Pct_Change'] <= df['Reg_Low_1std']

    prob_up_after_high_band = len(df[touched_high_band & (df['Next_Day_Direction'] == True)]) / len(df[touched_high_band])
    prob_down_after_high_band = 1 - prob_up_after_high_band

    prob_down_after_low_band = len(df[touched_low_band & (df['Next_Day_Direction'] == False)]) / len(df[touched_low_band])
    prob_up_after_low_band = 1 - prob_down_after_low_band

    # Probability based on consecutive days
    df['Streak'] = df['Direction'].groupby((df['Direction'] != df['Direction'].shift()).cumsum()).cumcount() + 1

    prob_up_after_streak_up = {}
    prob_down_after_streak_down = {}

    for i in range(1, 6):
        prob_up_after_streak_up[i] = len(df[(df['Streak'] == i) & (df['Direction'] == True) & (df['Next_Day_Direction'] == True)]) / len(df[(df['Streak'] == i) & (df['Direction'] == True)])
        prob_down_after_streak_down[i] = len(df[(df['Streak'] == i) & (df['Direction'] == False) & (df['Next_Day_Direction'] == False)]) / len(df[(df['Streak'] == i) & (df['Direction'] == False)])

    # Probability based on percentage moves
    thresholds = [0.5, 1.0, 1.5 ]
    prob_up_after_pct_move = {}
    prob_down_after_pct_move = {}

    for threshold in thresholds:
        prob_up_after_pct_move[f'{threshold}% up'] = len(df[(df['Pct_Change'] >= threshold) & (df['Next_Day_Direction'] == True)]) / len(df[df['Pct_Change'] >= threshold])
        prob_down_after_pct_move[f'{threshold}% up'] = 1 - prob_up_after_pct_move[f'{threshold}% up']
        prob_up_after_pct_move[f'{threshold}% down'] = len(df[(df['Pct_Change'] <= -threshold) & (df['Next_Day_Direction'] == True)]) / len(df[df['Pct_Change'] <= -threshold])
        prob_down_after_pct_move[f'{threshold}% down'] = 1 - prob_up_after_pct_move[f'{threshold}% down']

    stats = {
        "Probability of Up after Up": prob_up_after_up,
        "Probability of Down after Up": prob_down_after_up,
        "Probability of Down after Down": prob_down_after_down,
        "Probability of Up after Down": prob_up_after_down,
        "Probability of Up after High Band": prob_up_after_high_band,
        "Probability of Down after High Band": prob_down_after_high_band,
        "Probability of Down after Low Band": prob_down_after_low_band,
        "Probability of Up after Low Band": prob_up_after_low_band,
    }

    for i in range(1, 6):
        stats[f'Probability of Up after {i} Up Days'] = prob_up_after_streak_up[i]
        stats[f'Probability of Down after {i} Down Days'] = prob_down_after_streak_down[i]

    for key, value in prob_up_after_pct_move.items():
        stats[f'Probability of Up after {key}'] = value
    for key, value in prob_down_after_pct_move.items():
        stats[f'Probability of Down after {key}'] = value

    return stats

# Example usage:
ticker = "dia"  # Replace with desired ticker
ticker_data = download_data(ticker, period="1y")
ticker_data = add_linear_regression_bands(ticker_data)
plot_data(ticker_data, title=f"{ticker} Linear Regression Channel and Percentage Change")

# Calculate and display statistics
stats = calculate_statistics(ticker_data)
for key, value in stats.items():
    print(f"{key}: {value:.2%}")

import yfinance as yf
import pandas as pd
import plotly.graph_objs as go
import plotly.subplots as sp
from datetime import datetime
import os

def download_data(ticker, period):
    """Downloads data from yfinance for the specified ticker and period,
       saving it to a local directory structure."""
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)

    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")

    return df

def calculate_emas(df, spans):
    """Calculates Exponential Moving Averages (EMAs) for the given DataFrame and spans."""
    for span in spans:
        df[f"EMA{span}"] = df["Close"].ewm(span=span, adjust=False).mean()
    return df

def calculate_percent_differences(df, spans):
    """Calculates percent differences between each pair of EMAs."""
    for i in range(len(spans)):
        for j in range(i + 1, len(spans)):
            df[f"Diff_EMA{spans[i]}_EMA{spans[j]}"] = ((df[f"EMA{spans[j]}"] - df[f"EMA{spans[i]}"]) / df[f"EMA{spans[i]}"]) * 100
    return df

def add_linear_regression_channel(df):
    """Adds a linear regression channel to the DataFrame."""
    df['Pct_Change'] = df['Close'].pct_change() * 100
    df = df.dropna().reset_index(drop=True)

    df_numeric_index = pd.to_numeric(df.index)
    slope, intercept, _, _, _ = linregress(df_numeric_index, df['Pct_Change'])
    df.loc[:, 'Linear_Reg'] = intercept + slope * df_numeric_index
    df.loc[:, 'Residuals'] = df['Pct_Change'] - df['Linear_Reg']
    residuals_std = df['Residuals'].std()

    desired_values = [.5, 1, 1.25, 1.5, 1.75, 2, 2.25, 3, 4]

    for i, num_std in enumerate(desired_values):
        df.loc[:, f'Reg_High_{i+1}std'] = df['Linear_Reg'] + residuals_std * num_std
        df.loc[:, f'Reg_Low_{i+1}std'] = df['Linear_Reg'] - residuals_std * num_std

    return df

def plot_data(df, spans, title=""):
    """Plots the DataFrame using Plotly."""
    num_plots = sum(range(len(spans)))  # Number of subplot combinations
    cols = 2  # Number of columns in the subplot grid
    rows = -(-num_plots // cols)  # Calculate the number of rows needed (ceiling division)

    fig = sp.make_subplots(rows=rows, cols=cols, subplot_titles=[f"EMA {spans[i]} vs EMA {spans[j]}" for i in range(len(spans)) for j in range(i + 1, len(spans))])

    plot_idx = 1
    for i in range(len(spans)):
        for j in range(i + 1, len(spans)):
            trace_diff = go.Scatter(x=df.index, y=df[f"Diff_EMA{spans[i]}_EMA{spans[j]}"], mode='lines', name=f"Diff EMA{spans[i]}-EMA{spans[j]}")
            row = (plot_idx - 1) // cols + 1
            col = (plot_idx - 1) % cols + 1
            fig.add_trace(trace_diff, row=row, col=col)
            plot_idx += 1

    # Customize layout
    fig.update_layout(title=title, xaxis_title='Date', yaxis_title='Percent Difference', template='plotly_dark', height=1200, width=1600)

    fig.show()

# Example usage:
ticker = "AAPL"  # Replace "AAPL" with your desired ticker symbol
period = "1y"  # Define the period

ticker_data = download_data(ticker, period)
ticker_data = calculate_emas(ticker_data, spans=[50, 100, 150, 200, 300])
ticker_data = calculate_percent_differences(ticker_data, spans=[50, 100, 150, 200, 300])
ticker_data = add_linear_regression_channel(ticker_data)

# Plot data with highlights
plot_data(ticker_data, spans=[50, 100, 150, 200, 300], title=f"{ticker} Closing Price and EMAs with Percent Differences")

import yfinance as yf
import pandas as pd
import plotly.graph_objs as go
import os
from datetime import datetime

def download_data(ticker, period):
    """Downloads data from yfinance for the specified ticker and period,
       saving it to a local directory structure."""
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)

    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")

    return df

def calculate_emas(df, spans):
    """Calculates Exponential Moving Averages (EMAs) for the given DataFrame and spans."""
    for span in spans:
        df[f"EMA{span}"] = df["Close"].ewm(span=span, adjust=False).mean()
    return df

def calculate_percent_differences(df, spans):
    """Calculates percent differences between each pair of EMAs."""
    for i in range(len(spans)):
        for j in range(i + 1, len(spans)):
            df[f"Diff_EMA{spans[i]}_EMA{spans[j]}"] = ((df[f"EMA{spans[j]}"] - df[f"EMA{spans[i]}"]) / df[f"EMA{spans[i]}"]) * 100
    return df

def add_linear_regression_channel(df):
    """Adds a linear regression channel to the DataFrame."""
    df['Pct_Change'] = df['Close'].pct_change() * 100
    df = df.dropna().reset_index(drop=True)

    df_numeric_index = pd.to_numeric(df.index)
    slope, intercept, _, _, _ = linregress(df_numeric_index, df['Pct_Change'])
    df.loc[:, 'Linear_Reg'] = intercept + slope * df_numeric_index
    df.loc[:, 'Residuals'] = df['Pct_Change'] - df['Linear_Reg']
    residuals_std = df['Residuals'].std()

    desired_values = [.5, 1, 1.25, 1.5, 1.75, 2, 2.25, 3, 4]

    for i, num_std in enumerate(desired_values):
        df.loc[:, f'Reg_High_{i+1}std'] = df['Linear_Reg'] + residuals_std * num_std
        df.loc[:, f'Reg_Low_{i+1}std'] = df['Linear_Reg'] - residuals_std * num_std

    return df

def plot_data(df, spans, title=""):
    """Plots the DataFrame using Plotly."""
    fig = go.Figure()

    # Plot percent differences between EMAs
    for i in range(len(spans)):
        for j in range(i + 1, len(spans)):
            fig.add_trace(go.Scatter(
                x=df.index,
                y=df[f"Diff_EMA{spans[i]}_EMA{spans[j]}"],
                mode='lines',
                name=f"Diff EMA{spans[i]}-EMA{spans[j]}"
            ))

    # Add the linear regression channel to the main plot
    for i, num_std in enumerate([.5, 1, 1.25, 1.5, 1.75, 2, 2.25, 3, 4]):
        fig.add_trace(go.Scatter(
            x=df.index,
            y=df[f'Reg_High_{i+1}std'],
            line=dict(width=1, dash='dot'),
            name=f'Reg High {num_std} std'
        ))
        fig.add_trace(go.Scatter(
            x=df.index,
            y=df[f'Reg_Low_{i+1}std'],
            line=dict(width=1, dash='dot'),
            name=f'Reg Low {num_std} std'
        ))

    fig.update_layout(title=title, xaxis_title='Date', yaxis_title='Percent Difference', template='plotly_dark', height=800, width=1200)

    fig.show()

# Example usage:
ticker = "spy"  # Replace "AAPL" with your desired ticker symbol
period = "1y"  # Define the period

ticker_data = download_data(ticker, period)
ticker_data = calculate_emas(ticker_data, spans=[50, 100, 150, 200, 300])
ticker_data = calculate_percent_differences(ticker_data, spans=[50, 100, 150, 200, 300])
ticker_data = add_linear_regression_channel(ticker_data)

# Plot data with highlights
plot_data(ticker_data, spans=[50, 100, 150, 200, 300], title=f"{ticker} Closing Price and EMAs with Percent Differences")

# Import necessary libraries
import yfinance as yf
import pandas as pd
import plotly.graph_objs as go
import os
from datetime import datetime
import numpy as np
from scipy.stats import linregress

def download_data(ticker, period):
    """Downloads data from yfinance for the specified ticker and period,
       saving it to a local directory structure."""
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)

    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")

    return df

def add_linear_regression_curve(df, window=20, curve_color='cyan'):
    def linear_reg_slope_intercept(y_values):
        x_values = np.arange(len(y_values))
        slope, intercept, _, _, _ = linregress(x_values, y_values)
        return slope, intercept

    # Calculate slope and intercept for rolling window
    rolling_slope_intercept = df['Close'].rolling(window=window).apply(
        lambda x: linear_reg_slope_intercept(x)[0] * (window - 1) + linear_reg_slope_intercept(x)[1], raw=False)

    df[f'Linear_Regression_{window}'] = rolling_slope_intercept
    return df, curve_color

def calculate_linear_regression_curves(df, spans):
    """Calculates Linear Regression Curves for the given DataFrame and spans."""
    for span in spans:
        df, curve_color = add_linear_regression_curve(df, window=span, curve_color=f'Linear_Regression_{span}')
    return df

def calculate_percent_differences(df, spans):
    """Calculates percent differences between each pair of Linear Regression Curves."""
    for i in range(len(spans)):
        for j in range(i + 1, len(spans)):
            df[f"Diff_LR{spans[i]}_LR{spans[j]}"] = ((df[f"Linear_Regression_{spans[j]}"] - df[f"Linear_Regression_{spans[i]}"]) / df[f"Linear_Regression_{spans[i]}"]) * 100
    return df

def plot_data(df, spans, title=""):
    """Plots the DataFrame using Plotly."""
    fig = go.Figure()

    # Plot percent differences between Linear Regression Curves
    for i in range(len(spans)):
        for j in range(i + 1, len(spans)):
            fig.add_trace(go.Scatter(
                x=df.index,
                y=df[f"Diff_LR{spans[i]}_LR{spans[j]}"],
                mode='lines',
                name=f"Diff LR{spans[i]}-LR{spans[j]}"
            ))

    fig.update_layout(title=title, xaxis_title='Date', yaxis_title='Percent Difference', template='plotly_dark', height=800, width=1200)

    fig.show()

# Example usage:
ticker = "spy"  # Replace "AAPL" with your desired ticker symbol
period = "1y"  # Define the period

ticker_data = download_data(ticker, period)
ticker_data = calculate_linear_regression_curves(ticker_data, spans=[12, 20, 50, 100, 150])
ticker_data = calculate_percent_differences(ticker_data, spans=[12, 20, 50, 100, 150])

# Plot data with highlights
plot_data(ticker_data, spans=[12, 20, 50, 100, 150], title=f"{ticker} Closing Price and Linear Regression Curves with Percent Differences")

ticker = 'AAPL'
# @title Plot Linear Regression Channel
import yfinance as yf
import pandas as pd
import plotly.graph_objs as go
from scipy.stats import linregress
from datetime import datetime
import os

def download_data(ticker, period):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")
    return df

def add_linear_regression_bands(df):
    df['Pct_Change'] = df['Close'].pct_change() * 100
    df = df.dropna()

    df_numeric_index = pd.to_numeric(df.index)
    slope, intercept, _, _, _ = linregress(df_numeric_index, df['Pct_Change'])
    df['Linear_Reg'] = intercept + slope * df_numeric_index
    df['Residuals'] = df['Pct_Change'] - df['Linear_Reg']
    residuals_std = df['Residuals'].std()

    desired_values = [.5, 1, 1.25, 1.5, 1.75, 2, 2.25, 3, 4]

    for i, num_std in enumerate(desired_values):
        df[f'Reg_High_{i+1}std'] = df['Linear_Reg'] + residuals_std * num_std
        df[f'Reg_Low_{i+1}std'] = df['Linear_Reg'] - residuals_std * num_std

    return df

def plot_data(df, title):
    fig = go.Figure()

    # Define desired_values within the plot_data function
    desired_values = [.5, 1, 1.25, 1.5, 1.75, 2, 2.25, 3, 4]

    fig.add_trace(go.Scatter(x=df.index, y=df['Pct_Change'], mode='lines', name='Percentage Change'))

    fig.add_trace(go.Scatter(x=df.index, y=df['Linear_Reg'], line=dict(color='blue', width=2), name='Linear Regression'))
    colors = ['grey', 'green', 'orange', 'red', 'purple', 'brown', 'pink', 'gray', 'blue']  # Add more colors as needed
    for i, num_std in enumerate(desired_values):
        fig.add_trace(go.Scatter(
            x=df.index,
            y=df[f'Reg_High_{i+1}std'],
            line=dict(color=colors[i], width=1, dash='dot'),
            name=f'Reg High {num_std} std'
        ))
        fig.add_trace(go.Scatter(
            x=df.index,
            y=df[f'Reg_Low_{i+1}std'],
            line=dict(color=colors[i], width=1, dash='dot'),
            name=f'Reg Low {num_std} std'
        ))

    fig.update_layout(title=title, xaxis_title='Date', yaxis_title='Percentage Change', height=800, width=1200)
    fig.show()

# Example usage:
# ticker = "NKE"  # Replace with desired ticker
ticker_data = download_data(ticker, period="1y")
ticker_data = add_linear_regression_bands(ticker_data)

# Plot data with technical indicators
plot_data(ticker_data, title=f"{ticker} Linear Regression Channel and Percentage Change")

import yfinance as yf
import pandas as pd
import matplotlib.pyplot as plt
from datetime import datetime
import os

def download_or_load_data(symbols, start, end):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/etf_data.csv"

    try:
        data = pd.read_csv(data_file, index_col=0, parse_dates=True)
        print("Data found on disk.")
    except FileNotFoundError:
        data = yf.download(symbols, start=start, end=end)['Close']
        data.to_csv(data_file)
        print("Data downloaded and saved to disk.")

    return data

# Define the list of symbols for the ETFs
symbols = ['SPY', 'QQQ', 'IWM', 'GLD', 'TLT']

# Download or load the daily historical data for the ETFs
data = download_or_load_data(symbols, start="2020-01-01", end="2021-12-31")

# Calculate the daily returns for each ETF
returns = data.pct_change()

# Calculate the daily velocity (i.e., difference in returns) between each pair of ETFs
velocity = pd.DataFrame()
for i in range(len(symbols)):
    for j in range(i+1, len(symbols)):
        name = symbols[i] + '-' + symbols[j]
        velocity[name] = returns[symbols[i]] - returns[symbols[j]]

# Plot the daily velocity between each pair of ETFs
fig, axs = plt.subplots(5, 4, figsize=(12, 10))
for i in range(len(symbols)):
    for j in range(i+1, len(symbols)):
        name = symbols[i] + '-' + symbols[j]
        axs[i, j-1].plot(velocity[name])
        axs[i, j-1].set_title(name)
plt.tight_layout()
plt.show()

import yfinance as yf
import pandas as pd
import matplotlib.pyplot as plt
import os
from datetime import datetime

# Define the list of symbols for the ETFs
symbols = ['SHY', 'TLT', 'JNK', 'LQD', 'XLF', 'IEF', 'BIL']
start_date = "2023-09-01"
end_date = "2024-12-31"

def download_data(ticker, start_date, end_date):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"cached_data/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file, index_col='Date', parse_dates=True)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, start=start_date, end=end_date)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")
    return df

# Initialize a DataFrame to store all ETF data
all_data = pd.DataFrame()

# Download the daily historical data for each ETF, caching the results
for symbol in symbols:
    df = download_data(symbol, start_date, end_date)
    all_data[symbol] = df['Close']

# Normalize the data by the first day's price
normalized = all_data.divide(all_data.iloc[0])

# Plot the normalized data for each ETF on the same chart
fig, ax = plt.subplots(figsize=(12, 8))
normalized.plot(ax=ax)
ax.set_title('Normalized Daily Prices')
ax.set_xlabel('Date')
ax.set_ylabel('Normalized Price')
plt.show()

"""    SHY: iShares 1-3 Year Treasury Bond ETF, which invests in short-term U.S. Treasury bonds with maturities of 1-3 years.
    TLT: iShares 20+ Year Treasury Bond ETF, which invests in long-term U.S. Treasury bonds with maturities of 20 years or more.
    JNK: SPDR Bloomberg Barclays High Yield Bond ETF, which invests in high-yield corporate bonds with lower credit ratings.
    LQD: iShares iBoxx $ Investment Grade Corporate Bond ETF, which invests in investment-grade corporate bonds with higher credit ratings.
    XLF: Financial Select Sector SPDR Fund, which tracks the performance of the financial sector of the S&P 500.
    IEF : iShares 7-10 Year Treasury Bond ETF (IEF): This ETF invests in U.S. Treasury bonds with maturities between 7 and 10 ye
    BIL : SPDR Bloomberg Barclays 1-3 Month T-Bill ETF (BIL): This ETF invests in U. Treasury bills with maturities of 1-3 months, which are short-term debt securities issued by the U.S. government.
"""

import yfinance as yf
import pandas as pd
import matplotlib.pyplot as plt
import os
from datetime import datetime

# Define the list of symbols for the SPDR sector ETFs
symbols = ['XLC', 'XLY', 'XLP', 'XLE', 'XLF', 'XLV', 'XLI', 'XLK', 'XLB', 'XLRE', 'XLU']

def download_data(ticker, start_date, end_date):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file, index_col='Date', parse_dates=True)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, start=start_date, end=end_date)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")
    return df

# Download the daily historical data for the ETFs
all_data = pd.DataFrame()
start_date = "2022-09-01"
end_date = "2024-12-31"

for symbol in symbols:
    data = download_data(symbol, start_date, end_date)['Close']
    all_data[symbol] = data

# Normalize the data by the first day's price
normalized = all_data.divide(all_data.iloc[0])

# Plot the normalized data for each ETF on the same chart
fig, ax = plt.subplots(figsize=(12, 8))
normalized.plot(ax=ax)
ax.set_title('Normalized Daily Prices')
ax.set_xlabel('Date')
ax.set_ylabel('Normalized Price')
plt.show()

"""    Communication Services: Communication Services Select Sector SPDR Fund (XLC)
    Consumer Discretionary: Consumer Discretionary Select Sector SPDR Fund (XLY)
    Consumer Staples: Consumer Staples Select Sector SPDR Fund (XLP)
    Energy: Energy Select Sector SPDR Fund (XLE)
    Financials: Financial Select Sector SPDR Fund (XLF)
    Health Care: Health Care Select Sector SPDR Fund (XLV)
    Industrials: Industrial Select Sector SPDR Fund (XLI)
    Information Technology: Technology Select Sector SPDR Fund (XLK)
    Materials: Materials Select Sector SPDR Fund (XLB)
    Real Estate: Real Estate Select Sector SPDR Fund (XLRE)
    Utilities: Utilities Select Sector SPDR Fund (XLU)
"""

import yfinance as yf
import pandas as pd
import matplotlib.pyplot as plt
import os
from datetime import datetime

# Define the list of symbols for the SPDR sector ETFs
symbols = ['XLC', 'XLY', 'XLP', 'XLE', 'XLF', 'XLV', 'XLI', 'XLK', 'XLB', 'XLRE', 'XLU']

def download_data(ticker, start_date, end_date):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}_volume.csv"

    try:
        df = pd.read_csv(data_file, index_col='Date', parse_dates=True)
        print(f"Volume data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, start=start_date, end=end_date)['Volume']
        df.to_csv(data_file)
        print(f"Volume data for {ticker} downloaded and saved to disk.")
    return df

# Download the daily historical data for the ETFs
all_volume_data = pd.DataFrame()
start_date = "2022-09-01"
end_date = "2024-12-31"

for symbol in symbols:
    volume_data = download_data(symbol, start_date, end_date)
    all_volume_data[symbol] = volume_data

# Plot the daily trading volume for each ETF on the same chart
fig, ax = plt.subplots(figsize=(12, 8))
all_volume_data.plot(ax=ax)
ax.set_title('Daily Trading Volume')
ax.set_xlabel('Date')
ax.set_ylabel('Volume')
plt.show()

import yfinance as yf
import pandas as pd
import matplotlib.pyplot as plt
import os
from datetime import datetime

# Define the ticker symbol and period
symbol = "AAPL"
period = "2y"

def download_data(ticker, period):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"cached_data/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}.csv"

    try:
        data = pd.read_csv(data_file, index_col='Date', parse_dates=True)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        data = yf.download(ticker, period=period)
        data.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")
    return data

# Download stock data for a ticker symbol
data = download_data(symbol, period)

# Calculate the 50-day, 100-day, 200-day, and 300-day moving averages
data['MA50'] = data['Close'].rolling(window=50).mean()
data['MA100'] = data['Close'].rolling(window=100).mean()
data['MA200'] = data['Close'].rolling(window=200).mean()
data['MA300'] = data['Close'].rolling(window=300).mean()

# Calculate the daily change in the moving averages over the past week
data['MA50_velocity'] = data['MA50'].diff(7) / 7
data['MA100_velocity'] = data['MA100'].diff(7) / 7
data['MA200_velocity'] = data['MA200'].diff(7) / 7
data['MA300_velocity'] = data['MA300'].diff(7) / 7

# Plot the moving average velocities
plt.figure(figsize=(10, 5))
plt.plot(data.index, data['MA50_velocity'], label='50-day Price Moving Average Velocity')
plt.plot(data.index, data['MA100_velocity'], label='100-day Price Moving Average Velocity')
plt.plot(data.index, data['MA200_velocity'], label='200-day Price Moving Average Velocity')
plt.plot(data.index, data['MA300_velocity'], label='300-day Price Moving Average Velocity')
plt.legend()
plt.show()

#Using Volume :
import yfinance as yf
import pandas as pd
import matplotlib.pyplot as plt
import os
from datetime import datetime

# Download stock data for a ticker symbol with caching
def download_data(symbol, period):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"cached_data/{today_str}/{symbol}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{symbol}_volume.csv"

    try:
        data = pd.read_csv(data_file, index_col='Date', parse_dates=True)
        print(f"Volume data for {symbol} found on disk.")
    except FileNotFoundError:
        data = yf.download(symbol, period=period)
        data.to_csv(data_file)
        print(f"Volume data for {symbol} downloaded and saved to disk.")
    return data

# Define the stock symbol and period
symbol = "AAPL"
period = "2y"

# Download stock data
data = download_data(symbol, period)

# Calculate the 50-day, 100-day, 200-day, and 300-day moving averages of the volume
data['MA50'] = data['Volume'].rolling(window=50).mean()
data['MA100'] = data['Volume'].rolling(window=100).mean()
data['MA200'] = data['Volume'].rolling(window=200).mean()
data['MA300'] = data['Volume'].rolling(window=300).mean()

# Calculate the daily change in the volume moving averages over the past week
data['MA50_velocity'] = data['MA50'].diff(7) / 7
data['MA100_velocity'] = data['MA100'].diff(7) / 7
data['MA200_velocity'] = data['MA200'].diff(7) / 7
data['MA300_velocity'] = data['MA300'].diff(7) / 7

# Plot the moving average velocities
plt.figure(figsize=(10, 5))
plt.plot(data.index, data['MA50_velocity'], label='50-day Volume Moving Average Velocity')
plt.plot(data.index, data['MA100_velocity'], label='100-day Volume Moving Average Velocity')
plt.plot(data.index, data['MA200_velocity'], label='200-day Volume Moving Average Velocity')
plt.plot(data.index, data['MA300_velocity'], label='300-day Volume Moving Average Velocity')
plt.legend()
plt.show()

import yfinance as yf
import matplotlib.pyplot as plt
import numpy as np
import os
from datetime import datetime
import pandas as pd

# Define the stock symbol and time period
symbol = "AAPL"
period = "1y"

def download_data(ticker, period):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"cached_data/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}.csv"

    try:
        data = pd.read_csv(data_file, index_col='Date', parse_dates=True)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        data = yf.download(ticker, period=period)
        data.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")
    return data

# Download stock data for the symbol and time period with caching
data = download_data(symbol, period)

# Calculate the 50-day and 100-day exponential moving averages based on close price
ema50_close = data['Close'].ewm(span=50, adjust=False).mean()
ema100_close = data['Close'].ewm(span=100, adjust=False).mean()

# Calculate the absolute difference between the 50-day and 100-day exponential moving averages based on close price
ema_diff_abs_close = np.abs(ema50_close - ema100_close)

# Calculate the 50-day and 100-day exponential moving averages based on volume
ema50_volume = data['Volume'].ewm(span=50, adjust=False).mean()
ema100_volume = data['Volume'].ewm(span=100, adjust=False).mean()

# Calculate the absolute difference between the 50-day and 100-day exponential moving averages based on volume
ema_diff_abs_volume = np.abs(ema50_volume - ema100_volume)

# Create a new figure and plot the absolute difference between the 50-day and 100-day exponential moving averages based on close price
fig, (ax1, ax2) = plt.subplots(nrows=2, ncols=1, sharex=True, figsize=(10, 8))
ax1.plot(ema_diff_abs_close.index, ema_diff_abs_close.values, label='|EMA(50) - EMA(100)| (Close Price)', color='blue')
ax1.axhline(y=0, color='black', linestyle='--')
ax1.legend()
ax1.set_title('Absolute Exponential Moving Average Differences Price vs Volume for ' + symbol + ' (' + period + ')')

# Plot the absolute difference between the 50-day and 100-day exponential moving averages based on volume
ax2.plot(ema_diff_abs_volume.index, ema_diff_abs_volume.values, label='|EMA(50) - EMA(100)| (Volume)', color='red')
ax2.axhline(y=0, color='black', linestyle='--')
ax2.legend()

# Show the plot
plt.show()

import yfinance as yf
import mplfinance as mpf
import os
from datetime import datetime
import pandas as pd

# Define the stock symbol and time period
symbol = "AAPL"
#period = "3y"

def download_data(ticker, period):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"cached_data/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}.csv"

    try:
        data = pd.read_csv(data_file, index_col='Date', parse_dates=True)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        data = yf.download(ticker, period=period)
        data.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")
    return data

# Download stock data for the symbol and time period
data = download_data(symbol, period)

# Calculate the 50-day and 100-day moving averages
data['MA50'] = data['Close'].rolling(window=50).mean()
data['MA100'] = data['Close'].rolling(window=100).mean()

# Create a dictionary of arguments to pass to the `mpf.plot()` function
kwargs = dict(type='candle', volume=True, mav=(50, 100))

# Plot the data using the `mpf.plot()` function
mpf.plot(data, **kwargs, figratio=(10,5), figsize=(15,10), style='charles', figscale=2, tight_layout=True, ylabel='', hlines=dict(hlines=0, colors='g', linestyle='-'))

#import sys
#sys.exit("if you got this far, exiting on purpose")

