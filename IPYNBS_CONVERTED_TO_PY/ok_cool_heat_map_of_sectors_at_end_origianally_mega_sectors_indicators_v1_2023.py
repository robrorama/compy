# -*- coding: utf-8 -*-
"""ok_cool_heat_map_of_sectors_at_end_origianally_MEGA_SECTORS_INDICATORS_V1_2023.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ttgExcIszOqgSh1fy9sVAUpjvDa4u1Tl

The  things i am missing are ... the pie charts . should update this two show both buy ratings and .... shareholders
also need a relative to its sector line
"""

# ENTER YOUR TICKER SYMBOL ( it needs to be inside of two single quotes. after you set it go up to the top and select Runtime > Run ALL )
ticker='spy'
myPeriod='1y'

print(f'current ticker = {ticker}')

# Commented out IPython magic to ensure Python compatibility.
# #@title Download software
# # Download the needed ta-lib software
# %%capture
# import os
# if not os.path.exists('curl_ran.txt'):
#   !curl -L http://prdownloads.sourceforge.net/ta-lib/ta-lib-0.4.0-src.tar.gz -O && tar xzvf ta-lib-0.4.0-src.tar.gz >curl_ran.txt
# print('Downloaded package')

# Commented out IPython magic to ensure Python compatibility.
# #@title Compile the software
# # Download the needed ta-lib software ( note if you want to watch , comment out the %%capture with a hash mark)
# %%capture
# import os
# if not os.path.exists('compile_ran.txt'):
#   !cd ta-lib && ./configure --prefix=/usr && make && make install && cd - >compile_ran.txt
# print('compiled ta-lib')

# Commented out IPython magic to ensure Python compatibility.
# #@title Install ta-lib wrappers
# %%capture
# import os
# if not os.path.exists('pip_ran.txt'):
#   !pip install plotly
#   !pip install ta-lib
#   !pip install ta >pip_ran.txt
# print('installed ta-lib wrappers')

#tickers = ['AAPL', 'MSFT', 'AMZN', 'NVDA', 'GOOGL', 'TSLA', 'GOOG', 'BRK.B', 'UNH', 'XOM', 'LLY', 'JPM', 'JNJ', 'V', 'PG', 'AVGO', 'MA', 'HD', 'CVX', 'MRK', 'HON', 'KO', 'VZ', 'NKE', 'CRM', 'INTC', 'DOW', 'GS', 'CSCO', 'DUK', 'TRV', 'WMT', 'AMGN', 'DIS', 'WBA', 'CMCSA', 'MMM', 'AXP', 'CAT', 'IBM', 'MCD', 'PEP', 'ABBV', 'ACN', 'ATVI', 'ADBE', 'ADI', 'ADP', 'ADSK', 'ALGN', 'ALXN', 'ALGN', 'ALK', 'ALK', 'ALLE', 'LNT', 'ALXN', 'AMAT', 'AMD', 'AON', 'APA', 'APTV', 'ANET', 'APD']



#@title Percent change sector spyders
import yfinance as yf
import pandas as pd
import plotly.graph_objs as go
from datetime import datetime
import os
import numpy as np

def download_data(ticker, period):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")
    return df

def calculate_percent_change(df):
    df['Pct_Change'] = df['Close'].pct_change() * 100
    return df

def plot_sector_comparison(sectors, period):
    fig = go.Figure()

    for sector in sectors:
        sector_data = download_data(sector, period)
        sector_data = calculate_percent_change(sector_data)
        fig.add_trace(go.Scatter(x=sector_data.index, y=sector_data['Pct_Change'], mode='lines', name=sector))

    fig.update_layout(title='Percent Change Comparison', xaxis_title='Date', yaxis_title='Percent Change')
    fig.show()

# List of sector SPDRs
sectors = ['XLB', 'XLE', 'XLF', 'XLI', 'XLK', 'XLP', 'XLU', 'XLV', 'XLY']

dow = ['AAPL', 'MSFT', 'CRM', 'INTC', 'BA', 'V', 'JPM', 'AXP', 'IBM', 'MCD', 'CAT', 'HD', 'WMT', 'AMGN', 'DIS', 'GS', 'CSCO', 'DOW', 'NKE', 'UNH', 'TRV', 'PG', 'MRK', 'HON', 'KO', 'VZ', 'JNJ', 'MMM', 'CVX', 'WBA']
# Plot sector comparison
plot_sector_comparison(sectors, period="1y")

#@title Percent Change Dow Stocks
import yfinance as yf
import pandas as pd
import plotly.graph_objs as go
from datetime import datetime
import os
import time
import numpy as np

def download_data(ticker, period):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")
        time.sleep(1)  # 1-second delay after each download
    return df

def calculate_percent_change(df):
    df['Pct_Change'] = df['Close'].pct_change() * 100
    return df

def plot_dow_comparison(dow, period):
    fig = go.Figure()

    for stock in dow:
        stock_data = download_data(stock, period)
        stock_data = calculate_percent_change(stock_data)
        fig.add_trace(go.Scatter(x=stock_data.index, y=stock_data['Pct_Change'], mode='lines', name=stock))

    fig.update_layout(title='Dow Stocks Percent Change Comparison', xaxis_title='Date', yaxis_title='Percent Change')
    fig.show()

# List of Dow stocks
dow = ['AAPL', 'MSFT', 'CRM', 'INTC', 'BA', 'V', 'JPM', 'AXP', 'IBM', 'MCD', 'CAT', 'HD', 'WMT', 'AMGN', 'DIS', 'GS', 'CSCO', 'DOW', 'NKE', 'UNH', 'TRV', 'PG', 'MRK', 'HON', 'KO', 'VZ', 'JNJ', 'MMM', 'CVX', 'WBA']

# Plot Dow stocks comparison
plot_dow_comparison(dow, period="1y")

#@title price comparison the spyders :
import yfinance as yf
import pandas as pd
import plotly.graph_objs as go
from datetime import datetime
import os
import numpy as np

def download_or_read_data(ticker, period):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")
    return df

def plot_stock_prices(tickers, period, title):
    fig = go.Figure()

    for ticker in tickers:
        ticker_data = download_or_read_data(ticker, period)
        fig.add_trace(go.Scatter(x=ticker_data.index, y=ticker_data['Close'], mode='lines', name=ticker))

    fig.update_layout(title=title, xaxis_title='Date', yaxis_title='Price')
    fig.show()

# Sector SPDRs
sectors = ['XLB', 'XLE', 'XLF', 'XLI', 'XLK', 'XLP', 'XLU', 'XLV', 'XLY']
plot_stock_prices(sectors, period="1y", title="Sector SPDRs Price Comparison")

# Dow Stocks
dow = ['AAPL', 'MSFT', 'CRM', 'INTC', 'BA', 'V', 'JPM', 'AXP', 'IBM', 'MCD', 'CAT', 'HD', 'WMT', 'AMGN', 'DIS', 'GS', 'CSCO', 'DOW', 'NKE', 'UNH', 'TRV', 'PG', 'MRK', 'HON', 'KO', 'VZ', 'JNJ', 'MMM', 'CVX', 'WBA']
plot_stock_prices(dow, period="1y", title="Dow Stocks Price Comparison")

import plotly.graph_objs as go
import yfinance as yf
import pandas as pd
import os
from datetime import datetime
import time

def download_or_read_data(ticker, period='1y'):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")
        time.sleep(1)  # Delay to prevent hitting API limits
    return df

def get_stock_data(ticker):
    df = download_or_read_data(ticker, '1y')
    if df.empty:
        return None
    pct_change = ((df['Close'].iloc[-1] - df['Close'].iloc[0]) / df['Close'].iloc[0]) * 100
    last_close = df['Close'].iloc[-1]  # Use the last closing price to size the rectangles
    return ticker, pct_change, last_close

# Define your tickers here
tickers = ['AAPL', 'MSFT', 'CRM', 'INTC', 'BA', 'V', 'JPM', 'AXP', 'IBM', 'MCD', 'CAT', 'HD', 'WMT', 'AMGN', 'DIS', 'GS', 'CSCO', 'DOW', 'NKE', 'UNH', 'TRV', 'PG', 'MRK', 'HON', 'KO', 'VZ', 'JNJ', 'MMM', 'CVX', 'WBA']

# Fetch the stock data
stock_data = [get_stock_data(ticker) for ticker in tickers]

# Remove any None values
stock_data = [item for item in stock_data if item is not None]

# Prepare the data for the treemap
labels = [ticker for ticker, _, _ in stock_data]
values = [last_close for _, _, last_close in stock_data]  # Size of the rectangles
text = [f"{ticker}<br>YTD Change: {pct_change:.2f}%" for ticker, pct_change, _ in stock_data]  # Hover text

# Create the treemap
fig = go.Figure(go.Treemap(
    labels=labels,
    parents=[""] * len(labels),  # No parents since it's a flat structure
    values=values,
    text=text,
    marker=dict(
        colors=[pct_change for _, pct_change, _ in stock_data],
        colorscale='RdBu',
        cmid=0,  # Set the midpoint of the colorscale at 0
    ),
    hoverinfo="text+value",  # Show custom text and value on hover
))

fig.update_layout(
    margin=dict(t=0, l=0, r=0, b=0),
    title="YTD Percent Change and Last Close Price as Size"
)

# Show the figure
fig.show()

import plotly.graph_objs as go
import yfinance as yf
import pandas as pd
import os
from datetime import datetime
import time

def download_or_read_data(ticker, period='1y'):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")
        time.sleep(1)
    return df

# Define your tickers here (combined list from earlier)
all_tickers = [
    "SPY", "VT", "EEM", "DBC", "TIP", "IEF", "GLD", "BND", "DBV", "VSS", "DXY",
    "EEM", "OIL", "VIX", "XLB", "XLE", "XLF", "XLI", "XLK", "XLP", "XLU", "XLV", "XLY",
    'AAPL', 'MSFT', 'CRM', 'INTC', 'BA', 'V', 'JPM', 'AXP', 'IBM', 'MCD', 'CAT',
    'HD', 'WMT', 'AMGN', 'DIS', 'GS', 'CSCO', 'DOW', 'NKE', 'UNH', 'TRV', 'PG',
    'MRK', 'HON', 'KO', 'VZ', 'JNJ', 'MMM', 'CVX', 'WBA', 'IWM', 'QQQ'
]
# Fetch and process data
historical_data = {}
for ticker in all_tickers:
    data = download_or_read_data(ticker, '1y')
    if not data.empty:
        historical_data[ticker] = data['Close'].pct_change().dropna()

df_returns = pd.DataFrame(historical_data)
correlation_matrix = df_returns.corr()

# Prepare hovertext data
hovertext = [[f"{row}, {col}: {correlation_matrix.loc[row, col]:.2f}"
              for col in correlation_matrix.columns]
              for row in correlation_matrix.index]

# Create the heatmap with custom hovertext
fig = go.Figure(data=go.Heatmap(
    z=correlation_matrix.values,
    x=correlation_matrix.columns,
    y=correlation_matrix.index,
    colorscale='RdBu',
    hoverinfo='text',
    text=hovertext,
    zmin=-1, zmax=1
))

fig.update_layout(
    title='Correlation Matrix of ETFs, SPYDERs, DOW, and Macro Indicators',
    xaxis=dict(tickangle=-45),
    yaxis=dict(tickangle=45),
    margin=dict(t=100, l=200)
)

fig.show()

"""more research needed on etfs
also want to be able to find correlations that are lagging
"""

etfs_macro_indicators = [
    "SPY", # SPDR S&P 500 ETF
    "VT", # Vanguard Total World Stock ETF
    "EEM", # iShares MSCI Emerging Markets ETF
    "DBC", # Invesco DB Commodity Index Tracking Fund
    "TIP", # iShares TIPS Bond ETF
    "IEF", # iShares 7-10 Year Treasury Bond ETF
    "GLD", # SPDR Gold Shares
    "BND", # Vanguard Total Bond Market ETF
    "DBV", # Invesco DB G10 Currency Harvest Fund
    "VSS", # Vanguard FTSE All-World ex-US Small-Cap ETF
    "DXY", # U.S. Dollar Index
    "EEM", # iShares MSCI Emerging Markets ETF
    "OIL", # Crude Oil
    "VIX", # CBOE Volatility Index
    "GDP", # Gross Domestic Product
    "CPI", # Consumer Price Index
    "PPI", # Producer Price Index
    "U6", # Unemployment Rate
    "PMI", # Purchasing Managers' Index
    "GOLD", # Gold Price
    "BTC", # Bitcoin Price
]

commodity_etfs = [
    "DBC",  # Invesco DB Commodity Index Tracking Fund
    "GSG",  # iShares S&P GSCI Commodity-Indexed Trust
    "USCI",  # United States Commodity Index Fund
    "GCC",  # WisdomTree Enhanced Commodity Strategy Fund
    "PDBC",  # Invesco Optimum Yield Diversified Commodity Strategy No K-1 ETF
    "COMT",  # GraniteShares Bloomberg Commodity Broad Strategy No K-1 ETF
    "CMDY",  # iShares Bloomberg Roll Select Commodity Index Fund
    "FTGC",  # First Trust Global Tactical Commodity Strategy Fund
    "COM",  # iShares GSCI Commodity Dynamic Roll Strategy ETF
    "BCI",  # Barclays Bank PLC iPath Bloomberg Commodity Index Total Return ETN
]

commodity_etfs = [
    "DBC",  # Invesco DB Commodity Index Tracking Fund
    "GSG",  # iShares S&P GSCI Commodity-Indexed Trust
    "USCI",  # United States Commodity Index Fund
    "GCC",  # WisdomTree Enhanced Commodity Strategy Fund
    "PDBC",  # Invesco Optimum Yield Diversified Commodity Strategy No K-1 ETF
    "COMT",  # GraniteShares Bloomberg Commodity Broad Strategy No K-1 ETF
    "CMDY",  # iShares Bloomberg Roll Select Commodity Index Fund
    "FTGC",  # First Trust Global Tactical Commodity Strategy Fund
    "COM",  # iShares GSCI Commodity Dynamic Roll Strategy ETF
    "BCI",  # iShares Bloomberg Commodity Index Fund
    "WEAT",  # Teucrium Wheat Fund
    "SOYB",  # Teucrium Soybean Fund
    "CANE",  # Teucrium Sugar Fund
    "JJCB",  # iPath Series B Bloomberg Copper Subindex Total Return ETN
    "OILK",  # ProShares K-1 Free Crude Oil Strategy ETF
    "UGA",  # United States Gasoline Fund LP
    "UCO",  # ProShares Ultra Bloomberg Crude Oil
    "BNO",  # United States Brent Oil Fund LP
    "DBB",  # Invesco DB Base Metals Fund
    "JJC",  # iPath Series B Bloomberg Copper Subindex Total Return ETN
    "JJN",  # iPath Series B Bloomberg Nickel Subindex Total Return ETN
    "JJT",  # iPath Series B Bloomberg Tin Subindex Total Return ETN
    "JJU",  # iPath Series B Bloomberg Aluminum Subindex Total Return ETN
    "CMD",  # IQ Real Return ETF
    "GCC",  # WisdomTree Enhanced Commodity Strategy Fund
    "PDBC",  # Invesco Optimum Yield Diversified Commodity Strategy No K-1 ETF
    "COMT",  # GraniteShares Bloomberg Commodity Broad Strategy No K-1 ETF
    "BCI",  # iShares GSCI Commodity Dynamic Roll Strategy ETF
    "DEE",  # WisdomTree Commodity Country Equity Fund
    "GSG",  # iShares S&P GSCI Commodity-Indexed Trust
]

# i think i need to think about doing some pre-generation to show which ones based on things like beta / alpha , P/E , debt , percentage between high, low, slope of lrc







import sys ; sys.exit('nothing to be executed below this line : ')



#@title Download initial Data

import yfinance as yf
import pandas as pd
import plotly.graph_objs as go
from scipy.stats import linregress
from datetime import datetime
import os
#ticker='leave me commented out'
def download_data(ticker, period):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")
    return df



# Example usage:
ticker_data = download_data(ticker, period=myPeriod)
print(f"finished downloading data for {ticker}")

#@title Plot Linear Regression Channel
import yfinance as yf
import pandas as pd
import plotly.graph_objs as go
from scipy.stats import linregress
from datetime import datetime
import os

def download_data(ticker, period):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")
    return df

def add_linear_regression_bands(df):
    df_numeric_index = pd.to_numeric(df.index)
    slope, intercept, _, _, _ = linregress(df_numeric_index, df['Close'])
    df['Linear_Reg'] = intercept + slope * df_numeric_index
    df['Residuals'] = df['Close'] - df['Linear_Reg']
    residuals_std = df['Residuals'].std()

    desired_values = [.5, 1, 1.25, 1.5, 1.75, 2, 2.25, 3, 4]

    for i, num_std in enumerate(desired_values):
        df[f'Reg_High_{i+1}std'] = df['Linear_Reg'] + residuals_std * num_std
        df[f'Reg_Low_{i+1}std'] = df['Linear_Reg'] - residuals_std * num_std

    return df

def plot_data(df, title):
    fig = go.Figure()

    # Define desired_values within the plot_data function
    desired_values = [.5, 1, 1.25, 1.5, 1.75, 2, 2.25, 3, 4]


    fig.add_trace(go.Candlestick(x=df.index, open=df['Open'], high=df['High'], low=df['Low'], close=df['Close'], name='Market Data'))

    fig.add_trace(go.Scatter(x=df.index, y=df['Linear_Reg'], line=dict(color='blue', width=2), name='Linear Regression'))
    colors = ['grey', 'green', 'orange', 'red', 'purple', 'brown', 'pink', 'gray', 'blue']  # Add more colors as needed
    for i, num_std in enumerate(desired_values):
        fig.add_trace(go.Scatter(
            x=df.index,
            y=df[f'Reg_High_{i+1}std'],
            line=dict(color=colors[i], width=1, dash='dot'),
            name=f'Reg High {num_std} std'
        ))
        fig.add_trace(go.Scatter(
            x=df.index,
            y=df[f'Reg_Low_{i+1}std'],
            line=dict(color=colors[i], width=1, dash='dot'),
            name=f'Reg Low {num_std} std'
        ))

    fig.update_layout(title=title, xaxis_title='Date', yaxis_title='Price', height=800, width=1200)
    fig.show()

# Example usage:
#ticker = "NKE"  # Replace with desired ticker
ticker_data = download_data(ticker, period="2y")
ticker_data = add_linear_regression_bands(ticker_data)

# Plot data with technical indicators
plot_data(ticker_data, title=f"{ticker} Stock Analysis")

#@title Bollinger Bands, Volume, MACD, Stochastic, RSI
# Download the needed ta-lib software
import yfinance as yf
import pandas as pd
import plotly.graph_objs as go
import plotly.subplots
from ta.trend import MACD
from ta.momentum import StochasticOscillator, RSIIndicator
from datetime import datetime
import os

def download_data(ticker, period):
    """Downloads data from yfinance for the specified ticker and period."""
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)

    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")

    return df

def add_technical_indicators(df):
    """Adds moving averages, MACD, Stochastic, RSI, and Bollinger Bands to the DataFrame."""
    for span in [50, 100, 150, 200, 300]:
        df[f'MA{span}'] = df['Close'].rolling(window=span).mean()

    # MACD
    macd = MACD(close=df['Close'])
    df['MACD'] = macd.macd()
    df['MACD_Signal'] = macd.macd_signal()
    df['MACD_Diff'] = macd.macd_diff()

    # Stochastic Oscillator
    stoch = StochasticOscillator(high=df['High'], close=df['Close'], low=df['Low'])
    df['Stoch'] = stoch.stoch()
    df['Stoch_Signal'] = stoch.stoch_signal()

    # RSI
    rsi = RSIIndicator(close=df['Close'])
    df['RSI'] = rsi.rsi()

    # Bollinger Bands
    moving_average = df['Close'].rolling(window=20).mean()
    moving_std_dev = df['Close'].rolling(window=20).std()
    df['Bollinger_High'] = moving_average + (moving_std_dev * 2)
    df['Bollinger_Low'] = moving_average - (moving_std_dev * 2)

    return df

def plot_data(df, title):
    """Plots the DataFrame using Plotly with subplots for different indicators."""
    ## Initialize subplots
    ##fig = plotly.subplots.make_subplots(rows=5, cols=1, shared_xaxes=True, vertical_spacing=0.01)
    # Initialize subplots with custom heights
    fig = plotly.subplots.make_subplots(
    rows=5, cols=1, shared_xaxes=True,
    vertical_spacing=0.02,  # Adjust spacing to your preference
    subplot_titles=("Stock Data", "Volume", "MACD", "Stochastic", "RSI"),
    row_heights=[0.1, 0.03, 0.03, 0.03, 0.03])


    # Candlestick chart
    fig.add_trace(go.Candlestick(x=df.index, open=df['Open'], high=df['High'], low=df['Low'], close=df['Close'], name='Market Data'), row=1, col=1)

    # Moving Averages and Bollinger Bands
    #for span in [50, 100, 150, 200, 300]:
    #    fig.add_trace(go.Scatter(x=df.index, y=df[f'MA{span}'], opacity=0.7, name=f'MA {span}'), row=1, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['Bollinger_High'], line=dict(color='black', width=1), name='Bollinger High'), row=1, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['Bollinger_Low'], line=dict(color='black', width=1), name='Bollinger Low'), row=1, col=1)


    # MACD
    colors = ['green' if val >= 0 else 'red' for val in df['MACD_Diff']]
    fig.add_trace(go.Bar(x=df.index, y=df['MACD_Diff'], marker_color=colors), row=3, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['MACD'], line=dict(color='black', width=2)), row=3, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['MACD_Signal'], line=dict(color='blue', width=1)), row=3, col=1)


    # Volume
    colors = ['green' if row['Open'] - row['Close'] >= 0 else 'red' for index, row in df.iterrows()]
    fig.add_trace(go.Bar(x=df.index, y=df['Volume'], marker_color=colors), row=2, col=1)

    # Stochastic Oscillator
    fig.add_trace(go.Scatter(x=df.index, y=df['Stoch'], line=dict(color='black', width=1)), row=4, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['Stoch_Signal'], line=dict(color='blue', width=1)), row=4, col=1)

    # RSI
    fig.add_trace(go.Scatter(x=df.index, y=df['RSI'], line=dict(color='purple', width=1)), row=5, col=1)

    # Update layout
    ##fig.update_layout(height=1200, width=1200, showlegend=False, xaxis_rangeslider_visible=False)
    fig.update_layout(height=1500, width=1200, showlegend=False, xaxis_rangeslider_visible=False)
    fig.update_yaxes(title_text="Price", row=1, col=1)
    fig.update_yaxes(title_text="MACD", showgrid=False, row=3, col=1)
    fig.update_yaxes(title_text="Volume", row=2, col=1)
    fig.update_yaxes(title_text="Stochastic", row=4, col=1)
    fig.update_yaxes(title_text="RSI", row=5, col=1)

    fig.show()

# Example usage:
#ticker = "qqq"  # Replace with desired ticker
ticker_data = download_data(ticker, period="2y")
ticker_data = add_technical_indicators(ticker_data)

# Plot data with technical indicators
plot_data(ticker_data, title=f"{ticker} Stock Analysis")

#@title EMAs
import yfinance as yf
import pandas as pd
import plotly.graph_objs as go
import os
from datetime import datetime

def download_data(ticker, period):
    """Downloads data from yfinance for the specified ticker and period,
       saving it to a local directory structure."""
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)

    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")

    return df

def calculate_emas(df, spans):
    """Calculates Exponential Moving Averages (EMAs) for the given DataFrame and spans."""
    for span in spans:
        df[f"EMA{span}"] = df["Close"].ewm(span=span, adjust=False).mean()
    return df

def plot_data(df, title=""):
    """Plots the DataFrame using Plotly."""
    fig = go.Figure()

    # Plot Close price and EMAs
    fig.add_trace(go.Scatter(x=df.index, y=df['Close'], mode='lines', name='Close'))
    for span in [50, 100, 150, 200, 300]:
        fig.add_trace(go.Scatter(x=df.index, y=df[f'EMA{span}'], mode='lines', name=f'EMA{span}'))

    # Highlight the high and low points for the last 200 and 30 periods
    last_200_periods = df.iloc[-200:]
    last_30_periods = df.iloc[-30:]

    max_200 = last_200_periods['Close'].idxmax()
    min_200 = last_200_periods['Close'].idxmin()
    max_30 = last_30_periods['Close'].idxmax()
    min_30 = last_30_periods['Close'].idxmin()

    fig.add_trace(go.Scatter(x=[max_200], y=[last_200_periods['Close'].max()], mode='markers', marker=dict(color='green', size=10), name='High (200)'))
    fig.add_trace(go.Scatter(x=[min_200], y=[last_200_periods['Close'].min()], mode='markers', marker=dict(color='red', size=10), name='Low (200)'))
    fig.add_trace(go.Scatter(x=[max_30], y=[last_30_periods['Close'].max()], mode='markers', marker=dict(color='blue', size=10), name='High (30)'))
    fig.add_trace(go.Scatter(x=[min_30], y=[last_30_periods['Close'].min()], mode='markers', marker=dict(color='orange', size=10), name='Low (30)'))

    # Customize layout
    fig.update_layout(title=title, xaxis_title='Date', yaxis_title='Price', template='plotly_dark')

    fig.show()

# Example usage:
#ticker = "NKE"  # Replace "NKE" with your desired ticker symbol
ticker_data = download_data(ticker, period="5y")
ticker_data = calculate_emas(ticker_data, spans=[50, 100, 150, 200, 300])

# Plot data with highlights
plot_data(ticker_data, title=f"{ticker} Closing Price and EMAs with Highlights")

#@title MULTI-INDICATORS
import yfinance as yf
import pandas as pd
import plotly.graph_objs as go
from plotly.subplots import make_subplots
import os
from datetime import datetime
import talib

def download_data(ticker, period):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")
    return df

def calculate_indicators(df):
    # Calculate EMAs
    for span in [50, 100, 150, 200, 300]:
        df[f'EMA{span}'] = df['Close'].ewm(span=span, adjust=False).mean()

    # Calculate Bollinger Bands
    upperband, middleband, lowerband = talib.BBANDS(df['Close'], timeperiod=20, nbdevup=2, nbdevdn=2, matype=0)
    df['upperband'] = upperband
    df['middleband'] = middleband
    df['lowerband'] = lowerband

    # Calculate other indicators
    df['ADX'] = talib.ADX(df['High'], df['Low'], df['Close'], timeperiod=14)
    df['STDDEV'] = talib.STDDEV(df['Close'], timeperiod=5, nbdev=1)
    df['ATR'] = talib.ATR(df['High'], df['Low'], df['Close'], timeperiod=14)
    df['CMO'] = talib.CMO(df['Close'], timeperiod=14)
    df['ROC'] = talib.ROC(df['Close'], timeperiod=10)
    df['STOCH_k'], df['STOCH_d'] = talib.STOCH(df['High'], df['Low'], df['Close'])
    df['WILLR'] = talib.WILLR(df['High'], df['Low'], df['Close'], timeperiod=14)

    # Calculate Linear Regression Slope
    window = 14  # You can adjust the window period as needed
    df['LR_Slope'] = talib.LINEARREG_SLOPE(df['Close'], timeperiod=window)

    return df

def plot_data(df, title):
    # Create a subplot for each indicator with varying heights
    fig = make_subplots(rows=9, cols=1, shared_xaxes=True,
                        vertical_spacing=0.02,
                        subplot_titles=('Bollinger Bands', 'ADX', 'STDDEV', 'ATR', 'CMO', 'ROC', 'Stochastic', 'Williams %R', 'LR Slope'),
                        row_heights=[0.2, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05])

    # Plot Close price and Bollinger Bands with colors
    fig.add_trace(go.Scatter(x=df.index, y=df['Close'], mode='lines', name='Close', line=dict(color='blue', width=2)), row=1, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['upperband'], mode='lines', name='Upper Band', line=dict(color='green', width=1)), row=1, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['middleband'], mode='lines', name='Middle Band', line=dict(color='white', width=1)), row=1, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['lowerband'], mode='lines', name='Lower Band', line=dict(color='red', width=1)), row=1, col=1)

    # Plot other indicators in subplots with colors
    fig.add_trace(go.Scatter(x=df.index, y=df['ADX'], mode='lines', name='ADX', line=dict(color='lawngreen', width=1)), row=2, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['STDDEV'], mode='lines', name='STDDEV', line=dict(color='magenta', width=1)), row=3, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['ATR'], mode='lines', name='ATR', line=dict(color='blue', width=1)), row=4, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['CMO'], mode='lines', name='CMO', line=dict(color='red', width=1)), row=5, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['ROC'], mode='lines', name='ROC', line=dict(color='lime', width=1)), row=6, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['WILLR'], mode='lines', name='Williams %R', line=dict(color='cyan', width=1)), row=7, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['STOCH_k'], mode='lines', name='STOCH_k', line=dict(color='red', width=1)), row=8, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['STOCH_d'], mode='lines', name='STOCH_d', line=dict(color='blue', width=1)), row=8, col=1)

    # Add subplot for Linear Regression Slope
    fig.add_trace(go.Scatter(x=df.index, y=df['LR_Slope'], mode='lines', name='LR Slope', line=dict(color='yellow', width=1)), row=9, col=1)

    # Customize layout
    fig.update_layout(title=title, xaxis_title='Date', yaxis_title='Price', template='plotly_dark', height=2000, showlegend=False)

    # Customize y-axis labels for subplots
    fig.update_yaxes(title_text="Price", row=1, col=1)
    fig.update_yaxes(title_text="ADX", row=2, col=1)
    fig.update_yaxes(title_text="STDDEV", row=3, col=1)
    fig.update_yaxes(title_text="ATR", row=4, col=1)
    fig.update_yaxes(title_text="CMO", row=5, col=1)
    fig.update_yaxes(title_text="ROC", row=6, col=1)
    fig.update_yaxes(title_text="Williams %R", row=7, col=1)
    fig.update_yaxes(title_text="Stochastic", row=8, col=1)
    fig.update_yaxes(title_text="LR Slope", row=9, col=1)

    fig.show()

# Example usage:
# ticker = "AAPL"  # Replace with your desired ticker symbol
ticker_data = download_data(ticker, period="1y")
ticker_data = calculate_indicators(ticker_data)
plot_data(ticker_data, title=f"{ticker} Stock Data with Technical Indicators")

#@title UP/DONE Consecutive Days and Daily % moves
import yfinance as yf
import pandas as pd
import plotly.graph_objs as go
from plotly.subplots import make_subplots
from datetime import datetime
import os
import numpy as np

def download_data(ticker, period):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")
    return df

def calculate_consecutive_trends(df):
    df['Trend'] = np.sign(df['Close'].diff())
    df['Consecutive'] = df['Trend'].groupby((df['Trend'] != df['Trend'].shift()).cumsum()).cumcount() + 1
    df['Consecutive'] *= df['Trend']
    df['Pct_Change'] = df['Close'].pct_change() * 100
    return df

def plot_data_with_subplots(df, title):
    # Define row heights where the first two rows are half the size of the last two
    row_heights = [.1, .5, 1, 1]

    # Create subplots with 4 rows and custom row heights
    fig = make_subplots(rows=4, cols=1, shared_xaxes=True, vertical_spacing=0.02,
                        subplot_titles=(title, 'Market Data', 'Consecutive Days Up/Down', 'Daily Percentage Change'),
                        row_heights=row_heights)

    # Candlestick plot
    fig.add_trace(go.Candlestick(x=df.index, open=df['Open'], high=df['High'], low=df['Low'], close=df['Close'], name='Market Data'), row=1, col=1)

    # Consecutive trends subplot (new subplot)
    positive_consecutive = df['Consecutive'].apply(lambda x: x if x > 0 else 0)
    negative_consecutive = df['Consecutive'].apply(lambda x: x if x < 0 else 0)
    fig.add_trace(go.Bar(x=df.index, y=positive_consecutive, marker_color='green', name='Consecutive Up'), row=3, col=1)
    fig.add_trace(go.Bar(x=df.index, y=negative_consecutive, marker_color='red', name='Consecutive Down'), row=3, col=1)

    # Percentage change subplot
    fig.add_trace(go.Bar(x=df.index, y=df['Pct_Change'], marker_color=df['Pct_Change'].apply(lambda x: 'blue' if x > 0 else 'orange'), name='Percentage Change'), row=4, col=1)

    # Update layout
    # Adjust the height to accommodate the custom row heights
    fig.update_layout(height=1800, showlegend=False)

    # Show the figure
    fig.show()


def plot_data_with_subplotsOLD(df, title):
    # Create subplots with 4 rows
    fig = make_subplots(rows=4, cols=1, shared_xaxes=True, vertical_spacing=0.02, subplot_titles=(title, 'Market Data', 'Consecutive Days Up/Down ', 'Daily Percentage Change'))

    # Candlestick plot
    fig.add_trace(go.Candlestick(x=df.index, open=df['Open'], high=df['High'], low=df['Low'], close=df['Close'], name='Market Data'), row=1, col=1)

    # Consecutive trends subplot (new subplot)
    # We separate positive and negative consecutive trends for correct plotting
    positive_consecutive = df['Consecutive'].apply(lambda x: x if x > 0 else 0)
    negative_consecutive = df['Consecutive'].apply(lambda x: x if x < 0 else 0)
    fig.add_trace(go.Bar(x=df.index, y=positive_consecutive, marker_color='green', name='Consecutive Up'), row=3, col=1)
    fig.add_trace(go.Bar(x=df.index, y=negative_consecutive, marker_color='red', name='Consecutive Down'), row=3, col=1)

    # Percentage change subplot
    fig.add_trace(go.Bar(x=df.index, y=df['Pct_Change'], marker_color=df['Pct_Change'].apply(lambda x: 'blue' if x > 0 else 'orange'), name='Percentage Change'), row=4, col=1)

    # Update layout
    fig.update_layout(height=1600, showlegend=False)

    # Show the figure
    fig.show()





# Example usage:
#ticker = "AAPL"  # Replace with desired ticker
ticker_data = download_data(ticker, period="50y")
ticker_data = calculate_consecutive_trends(ticker_data)

# Plot data with subplots
plot_data_with_subplots(ticker_data, title=f"{ticker} Stock ")



#@title consecutive days up / down
import yfinance as yf
import pandas as pd
import plotly.graph_objs as go
from plotly.subplots import make_subplots
from datetime import datetime
import os
import numpy as np
import scipy.stats as stats

def download_data(ticker, period):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")
    return df

def calculate_consecutive_trends(df):
    df['Trend'] = np.sign(df['Close'].diff())
    df['Consecutive'] = df['Trend'].groupby((df['Trend'] != df['Trend'].shift()).cumsum()).cumcount() + 1
    df['Consecutive'] *= df['Trend']
    df['Pct_Change'] = df['Close'].pct_change() * 100
    return df

def plot_histograms_and_gaussian(df, title):
    # Separate the data into positive and negative consecutive days
    positive_consecutive = df['Consecutive'][df['Consecutive'] > 0]
    negative_consecutive = df['Consecutive'][df['Consecutive'] < 0]

    # Create subplots: 1 row, 2 columns
    fig = make_subplots(rows=1, cols=2, subplot_titles=('Consecutive Days Up', 'Consecutive Days Down'))

    # Histogram for positive consecutive days
    fig.add_trace(go.Histogram(x=positive_consecutive, name='Consecutive Up'), row=1, col=2)

    # Histogram for negative consecutive days
    fig.add_trace(go.Histogram(x=negative_consecutive, name='Consecutive Down'), row=1, col=1)


    # Gaussian Distribution for negative consecutive days
    if len(negative_consecutive) > 0:
        mean_neg = np.mean(negative_consecutive)
        std_dev_neg = np.std(negative_consecutive)
        x_neg = np.linspace(min(negative_consecutive), max(negative_consecutive), 100)
        gaussian_distribution_neg = stats.norm.pdf(x_neg, mean_neg, std_dev_neg)
        #fig.add_trace(go.Scatter(x=x_neg, y=gaussian_distribution_neg, mode='lines', name='Gaussian Down'), row=1, col=2)

    # Gaussian Distribution for positive consecutive days
    if len(positive_consecutive) > 0:
        mean_pos = np.mean(positive_consecutive)
        std_dev_pos = np.std(positive_consecutive)
        x_pos = np.linspace(min(positive_consecutive), max(positive_consecutive), 100)
        gaussian_distribution_pos = stats.norm.pdf(x_pos, mean_pos, std_dev_pos)
        #fig.add_trace(go.Scatter(x=x_pos, y=gaussian_distribution_pos, mode='lines', name='Gaussian Up'), row=1, col=1)


    # Update layout
    fig.update_layout(title=f'Consecutive Days and Gaussian Distribution for {title}', barmode='overlay')

    # Show the figure
    fig.show()

# Example usage
#ticker = "AAPL"  # Replace with desired ticker
ticker_data = download_data(ticker, period="50y")
ticker_data = calculate_consecutive_trends(ticker_data)

# Plot histograms and Gaussian distributions
plot_histograms_and_gaussian(ticker_data, title=f"{ticker} Stock")



#@title candle stick patterns :
import yfinance as yf
import pandas as pd
import plotly.graph_objs as go
import talib
from datetime import datetime
import os

def download_data(ticker, period):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")
    return df

def add_selected_candlestick_patterns(df):
    # Selected patterns
    selected_patterns = ['CDLHAMMER', 'CDLINVERTEDHAMMER', 'CDLENGULFING',
                         'CDLPIERCING', 'CDLDARKCLOUDCOVER', 'CDLDOJI',
                         'CDLMORNINGSTAR', 'CDLEVENINGSTAR', 'CDLSHOOTINGSTAR',
                         'CDLHARAMI']

    for pattern in selected_patterns:
        pattern_function = getattr(talib, pattern)
        df[pattern] = pattern_function(df['Open'], df['High'], df['Low'], df['Close'])

    return df

def plot_data(df, title):
    fig = go.Figure()

    fig.add_trace(go.Candlestick(x=df.index, open=df['Open'], high=df['High'], low=df['Low'], close=df['Close'], name='Market Data'))

    # Highlight the selected patterns on the chart
    for pattern in ['CDLHAMMER', 'CDLINVERTEDHAMMER', 'CDLENGULFING',
                    'CDLPIERCING', 'CDLDARKCLOUDCOVER', 'CDLDOJI',
                    'CDLMORNINGSTAR', 'CDLEVENINGSTAR', 'CDLSHOOTINGSTAR',
                    'CDLHARAMI']:
        fig.add_trace(go.Scatter(
            x=df.index,
            y=df[pattern],
            mode='markers',
            name=pattern[3:]
        ))

    fig.update_layout(title=title, xaxis_title='Date', yaxis_title='Price', height=800, width=1200)
    fig.show()

# Example usage:
#ticker = "NKE"  # Replace with desired ticker
ticker_data = download_data(ticker, period="2y")
ticker_data = add_selected_candlestick_patterns(ticker_data)

# Plot data with technical indicators
plot_data(ticker_data, title=f"{ticker} Stock Analysis")

#@title OPTIONS GRAPHS
import yfinance as yf
import pandas as pd
import plotly.express as px
import os
from datetime import datetime, timedelta

# Set the ticker and desired date for options data
#ticker = 'AAPL'  # Replace 'AAPL' with your stock's ticker
myWeeks=4
target_date = datetime.today() + timedelta(weeks=myWeeks)

def download_options_data(ticker, date):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/options.{date}.{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        print(f"Options data for {ticker} found on disk.")
    except FileNotFoundError:
        # Download options data
        stock = yf.Ticker(ticker)
        options = stock.option_chain(date)
        df = pd.concat([options.calls, options.puts])
        df.to_csv(data_file)
        print(f"Options data for {ticker} downloaded and saved to disk.")
    return df

# Find the nearest options date and get current stock price
stock = yf.Ticker(ticker)
options_dates = stock.options
nearest_date = min(options_dates, key=lambda d: abs(datetime.strptime(d, "%Y-%m-%d") - target_date))
current_price = stock.history(period="1d")['Close'].iloc[-1]

# Download data
options_data = download_options_data(ticker, nearest_date)

# Split the data into calls and puts
calls_data = options_data[options_data['contractSymbol'].str.contains('C')]
puts_data = options_data[options_data['contractSymbol'].str.contains('P')]

# Replace NaN values in 'volume' with a default size for both calls and puts
default_size_calls = calls_data['volume'].dropna().min()
default_size_puts = puts_data['volume'].dropna().min()
calls_data['volume'].fillna(default_size_calls, inplace=True)
puts_data['volume'].fillna(default_size_puts, inplace=True)

# Custom function to create scatter plot
# Custom function to create scatter plot
def create_plot(data, color_scale, title):
    fig = px.scatter(data, x="strike", y="openInterest",
                     size="openInterest", color="openInterest",
                     opacity=0.8, color_continuous_scale=color_scale)

    fig.update_layout(title=f"{ticker} {title} (Strike vs. Open Interest) - Current Price: ${current_price:.2f}",
                      xaxis_title="Strike Price", yaxis_title="Open Interest",
                      xaxis_showgrid=False, yaxis_showgrid=False,
                      plot_bgcolor='black', paper_bgcolor='black',
                      font_color='white')
    return fig

def create_plotOrig(data, color_scale, title):
    fig = px.scatter(data, x="strike", y="openInterest",
                     size="volume", color="volume",
                     opacity=0.8, color_continuous_scale=color_scale)

    fig.update_layout(title=f"{ticker} {title} (Strike vs. Open Interest) - Current Price: ${current_price:.2f}",
                      xaxis_title="Strike Price", yaxis_title="Open Interest",
                      xaxis_showgrid=False, yaxis_showgrid=False,
                      plot_bgcolor='black', paper_bgcolor='black',
                      font_color='white')
    return fig

# Plotting Calls
fig_calls = create_plot(calls_data, "Blues", "Call Options")
fig_calls.show()

# Plotting Puts
fig_puts = create_plot(puts_data, "Reds", "Put Options")
fig_puts.show()



#@title PUT/CALL Ratios
import yfinance as yf
import pandas as pd
import plotly.express as px
import os
from datetime import datetime, timedelta

# Set the ticker and desired date for options data
#ticker = 'AAPL'  # Replace 'AAPL' with your stock's ticker
#myWeeks=4 # defined in the options
target_date = datetime.today() + timedelta(weeks=myWeeks)

def download_options_data(ticker, date):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/options.{date}.{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        print(f"Options data for {ticker} found on disk.")
    except FileNotFoundError:
        # Download options data
        stock = yf.Ticker(ticker)
        options = stock.option_chain(date)
        df = pd.concat([options.calls, options.puts])
        df.to_csv(data_file)
        print(f"Options data for {ticker} downloaded and saved to disk.")
    return df

# Find the nearest options date and get current stock price
stock = yf.Ticker(ticker)
options_dates = stock.options
nearest_date = min(options_dates, key=lambda d: abs(datetime.strptime(d, "%Y-%m-%d") - target_date))

# Download data
options_data = download_options_data(ticker, nearest_date)

# Split the data into calls and puts
calls_data = options_data[options_data['contractSymbol'].str.contains('C')]
puts_data = options_data[options_data['contractSymbol'].str.contains('P')]

# Calculate put/call ratio for each strike price
combined_data = pd.merge(calls_data[['strike', 'openInterest']], puts_data[['strike', 'openInterest']], on='strike', suffixes=('_call', '_put'))
combined_data['put_call_ratio'] = combined_data['openInterest_put'] / combined_data['openInterest_call']
combined_data = combined_data.dropna()

# Plotting Put/Call Ratio
fig = px.bar(combined_data, x='strike', y='put_call_ratio', title='Put/Call Ratio by Strike Price')
fig.update_layout(xaxis_title='Strike Price', yaxis_title='Put/Call Ratio', plot_bgcolor='black', paper_bgcolor='black', font_color='white')
fig.show()

"""The put/call ratio is a popular sentiment indicator that gauges the overall mood of the market towards a stock. Here's how to interpret the put/call ratio chart based on the image you provided:

Ratio Values:

A put/call ratio greater than 1 indicates that there are more puts than calls, suggesting that investors are potentially expecting the stock's price to decline.
A put/call ratio less than 1 means there are more calls than puts, suggesting a bullish outlook where investors expect the price to rise.
Specific Strikes:

High ratios at specific strike prices may point to areas where investors feel particularly strong about potential downward movement in the stock's price.
Conversely, lower ratios may highlight confidence in potential upward movement, especially if the strikes are above the current stock price.
High Ratios:

Extremely high ratios, as seen in your chart at certain strike prices, could suggest that investors are either heavily hedging their positions expecting a downturn or speculating on a decrease in the stock's price.
Be cautious with outlier values; they could be influenced by large individual trades and may not reflect broader market sentiment.
Strike Prices Near Current Stock Price:

The put/call ratio at strike prices close to the current stock price can be particularly telling. If these ratios are high, it indicates a bearish sentiment near the current market price. If they are low, it indicates bullish sentiment.
Overall Interpretation:

The general level of the put/call ratio across all strikes can give you an overall sentiment indication. If most of the ratios across strikes are above 1, it could be interpreted as bearish. If they are below 1, it could be bullish.
It's also important to compare the put/call ratio with historical averages for the ticker. A ratio that's high relative to historical norms can indicate more bearish sentiment than usual, and vice versa.
Market Context:

The put/call ratio should not be used in isolation. Market context, news, upcoming events (like earnings reports), and technical analysis should all be considered when interpreting this ratio.
Trading Volume:

Ensure that the analysis accounts for the volume of trades. A high ratio on low volume may not be as significant as a slightly lower ratio on high volume.
In the chart you've shared, you'd look for clusters of high or low ratios and their respective strike prices to analyze sentiment. If high ratios cluster above the current price and low ratios below it, this could indicate a bearish skew in expectations. If it's the opposite, with low ratios above and high ratios below, it could suggest bullish sentiment.
"""

#@title Compare stock's relative performance by its sector
import yfinance as yf
import pandas as pd
import plotly.graph_objs as go
from scipy.stats import linregress
from datetime import datetime
import os

def download_data(ticker, period):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}.csv"
    sector_file = f"{data_dir}/{ticker}_sector.csv"

    # Fetching the stock data
    try:
        df = pd.read_csv(data_file)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")

    # Fetching the sector information
    stock = yf.Ticker(ticker)
    sector = stock.info.get("sector", "Unknown")
    with open(sector_file, 'w') as file:
        file.write(f"{ticker},{sector}")
        print(f"Sector information for {ticker} saved to disk.")

    return df, sector

def add_linear_regression_bands(df):
    df_numeric_index = pd.to_numeric(df.index)
    slope, intercept, _, _, _ = linregress(df_numeric_index, df['Close'])
    df['Linear_Reg'] = intercept + slope * df_numeric_index
    df['Residuals'] = df['Close'] - df['Linear_Reg']
    residuals_std = df['Residuals'].std()

    desired_values = [.5, 1, 1.25, 1.5, 1.75, 2, 2.25, 3, 4]

    for i, num_std in enumerate(desired_values):
        df[f'Reg_High_{i+1}std'] = df['Linear_Reg'] + residuals_std * num_std
        df[f'Reg_Low_{i+1}std'] = df['Linear_Reg'] - residuals_std * num_std

    return df

def plot_data(df, title):
    fig = go.Figure()

    # Define desired_values within the plot_data function
    desired_values = [.5, 1, 1.25, 1.5, 1.75, 2, 2.25, 3, 4]

    fig.add_trace(go.Candlestick(x=df.index, open=df['Open'], high=df['High'], low=df['Low'], close=df['Close'], name='Market Data'))
    fig.add_trace(go.Scatter(x=df.index, y=df['Linear_Reg'], line=dict(color='blue', width=2), name='Linear Regression'))

    colors = ['grey', 'green', 'orange', 'red', 'purple', 'brown', 'pink', 'gray', 'blue']  # Add more colors as needed
    for i, num_std in enumerate(desired_values):
        fig.add_trace(go.Scatter(
            x=df.index,
            y=df[f'Reg_High_{i+1}std'],
            line=dict(color=colors[i], width=1, dash='dot'),
            name=f'Reg High {num_std} std'
        ))
        fig.add_trace(go.Scatter(
            x=df.index,
            y=df[f'Reg_Low_{i+1}std'],
            line=dict(color=colors[i], width=1, dash='dot'),
            name=f'Reg Low {num_std} std'
        ))

    fig.update_layout(title=title, xaxis_title='Date', yaxis_title='Price', height=800, width=1200)
    fig.show()


def plot_dataOrig(df, title):
    fig = go.Figure()

    fig.add_trace(go.Candlestick(x=df.index, open=df['Open'], high=df['High'], low=df['Low'], close=df['Close'], name='Market Data'))

    fig.add_trace(go.Scatter(x=df.index, y=df['Linear_Reg'], line=dict(color='blue', width=2), name='Linear Regression'))
    colors = ['grey', 'green', 'orange', 'red', 'purple', 'brown', 'pink', 'gray', 'blue']  # Add more colors as needed
    for i, num_std in enumerate(desired_values):
        fig.add_trace(go.Scatter(
            x=df.index,
            y=df[f'Reg_High_{i+1}std'],
            line=dict(color=colors[i], width=1, dash='dot'),
            name=f'Reg High {num_std} std'
        ))
        fig.add_trace(go.Scatter(
            x=df.index,
            y=df[f'Reg_Low_{i+1}std'],
            line=dict(color=colors[i], width=1, dash='dot'),
            name=f'Reg Low {num_std} std'
        ))

    fig.update_layout(title=title, xaxis_title='Date', yaxis_title='Price', height=800, width=1200)
    fig.show()

# Example usage:
#ticker = "NKE"  # Replace with desired ticker
ticker_data, sector = download_data(ticker, period="2y")
ticker_data = add_linear_regression_bands(ticker_data)

# Plot data with technical indicators
plot_data(ticker_data, title=f"{ticker} Stock Analysis - Sector: {sector}")

#@title JUST CANDLESTICKS
import yfinance as yf
import pandas as pd
import plotly.graph_objs as go
from scipy.signal import argrelextrema
from datetime import datetime
import os
import numpy as np

def download_data(ticker, period):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")
    return df

def find_support_resistance(df, window=100):
    # Find local maxima for resistance
    df['resistance'] = df['High'][argrelextrema(df['High'].values, np.greater_equal, order=window)[0]]

    # Find local minima for support
    df['support'] = df['Low'][argrelextrema(df['Low'].values, np.less_equal, order=window)[0]]

    return df

def plot_data(df, title):
    fig = go.Figure()

    fig.add_trace(go.Candlestick(x=df.index, open=df['Open'], high=df['High'], low=df['Low'], close=df['Close'], name='Market Data'))

    # Plot support and resistance
    fig.add_trace(go.Scatter(x=df.index, y=df['support'], line=dict(color='green', width=1), name='Support'))
    fig.add_trace(go.Scatter(x=df.index, y=df['resistance'], line=dict(color='red', width=1), name='Resistance'))

    fig.update_layout(title=title, xaxis_title='Date', yaxis_title='Price', height=800, width=1200)
    fig.show()

# Example usage:
#ticker = "NKE"  # Replace with desired ticker
ticker_data = download_data(ticker, period="2y")
ticker_data = find_support_resistance(ticker_data)

# Plot data with support and resistance
plot_data(ticker_data, title=f"{ticker} Stock Analysis")

#@title 50,100,150,200,300 Original View
import yfinance as yf
import pandas as pd
import matplotlib.pyplot as plt
import os
from datetime import datetime

def download_data(ticker, period):
    """Downloads data from yfinance for the specified ticker and period,
       saving it to a local directory structure.
    """
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)  # Create directories if needed, including the root DATA directory

    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")

    return df

def calculate_emas(df, spans):
    """Calculates Exponential Moving Averages (EMAs) for the given DataFrame and spans."""
    for span in spans:
        df[f"EMA{span}"] = df["Close"].ewm(span=span, min_periods=span).mean()
    return df

def plot_data(df, columns, highlight_data=None, title=""):
    """Plots the specified columns from the DataFrame, with optional highlights."""
    plt.figure(figsize=(12, 6))

    # Plot the entire dataset
    df[columns].plot(label=columns, style=["b-", "-", "-", "-", "-"])

    # Process and plot the highlights
    if highlight_data:
        # Data for the last 200 and 30 periods
        last_200_periods = df.iloc[-200:]
        last_30_periods = df.iloc[-30:]

        for h_type, data, color, label in highlight_data:
            if h_type == "max":
                # Max in last 200 periods
                max_point_200 = last_200_periods[data.name].idxmax()
                plt.scatter(max_point_200, last_200_periods.loc[max_point_200, data.name], c=color, s=200, label=label + " (200)")

                # Max in last 30 periods
                max_point_30 = last_30_periods[data.name].idxmax()
                plt.scatter(max_point_30, last_30_periods.loc[max_point_30, data.name], c=color, s=100, label=label + " (30)")

            elif h_type == "min":
                # Min in last 200 periods
                min_point_200 = last_200_periods[data.name].idxmin()
                plt.scatter(min_point_200, last_200_periods.loc[min_point_200, data.name], c=color, s=200, label=label + " (200)")

                # Min in last 30 periods
                min_point_30 = last_30_periods[data.name].idxmin()
                plt.scatter(min_point_30, last_30_periods.loc[min_point_30, data.name], c=color, s=100, label=label + " (30)")

    # Customize styling and display
    plt.title(title)
    plt.xlabel("Period")  # Adjust label as needed
    plt.ylabel("Price")
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    plt.show()



def plot_dataSecond(df, columns, highlight_data=None, title=""):
    """Plots the specified columns from the DataFrame, with optional highlights."""
    plt.figure(figsize=(12, 6))

    # Plot the entire dataset
    df[columns].plot(label=columns, style=["b-", "-", "-", "-", "-"])

    # Process and plot the highlights for the last 200 periods
    if highlight_data:
        last_200_periods = df.iloc[-200:]  # Data for the last 200 periods

        for h_type, data, color, label in highlight_data:
            if h_type == "max":
                max_point = last_200_periods[data.name].idxmax()  # Get index of max value in the last 200 periods
                plt.scatter(max_point, last_200_periods.loc[max_point, data.name], c=color, s=200, label=label)
            elif h_type == "min":
                min_point = last_200_periods[data.name].idxmin()  # Get index of min value in the last 200 periods
                plt.scatter(min_point, last_200_periods.loc[min_point, data.name], c=color, s=200, label=label)

    # Customize styling and display
    plt.title(title)
    plt.xlabel("Period")  # Adjust label as needed
    plt.ylabel("Price")
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    plt.show()



def plot_dataOrig(df, columns, highlight_data=None, title=""):
    """Plots the specified columns from the DataFrame, with optional highlights."""
    plt.figure(figsize=(12, 6))

    # Filter for the last 200 periods directly based on the numeric index
    last_200_periods = df.iloc[-200:]

    # Plot the filtered data
    last_200_periods[columns].plot(label=columns, style=["b-", "-", "-", "-", "-"])

    # Add optional highlights (if applicable)
    if highlight_data:
        filtered_highlight_data = []  # Create a list to store filtered highlight data
        for h_type, data, color, label in highlight_data:
            filtered_data = data.iloc[-200:]  # Filter highlight data to match the last 200 periods
            filtered_highlight_data.append((h_type, filtered_data, color, label))

        for h_type, data, color, label in filtered_highlight_data:
            if h_type == "max":
                plt.scatter(last_200_periods.index[data == data.max()], data.max(), c=color, s=200, label=label)
            elif h_type == "min":
                plt.scatter(last_200_periods.index[data == data.min()], data.min(), c=color, s=200, label=label)

    # Customize styling and display
    plt.title(title)
    plt.xlabel("Period")  # Adjust label as needed
    plt.ylabel("Price")
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    plt.show()

# Example usage:
#ticker = "fdx"  # Replace "NKE" with your desired ticker symbol
ticker_data = download_data(ticker, period="1y")
ticker_data = calculate_emas(ticker_data, spans=[50, 100, 150, 200, 300])

# Define highlight data (adjust as needed)
highlight_data = [
    ("max", ticker_data["Close"], "green", f"Highest Close (Last 200 Periods) for {ticker}"),  # Adjust label as needed
    ("min", ticker_data["Close"], "red", f"Lowest Close (Last 200 Periods) for {ticker}"),  # Adjust label as needed
]

# Plot data with highlights for the last 200 periods
plot_data(ticker_data, columns=["Close", "EMA50", "EMA100", "EMA150", "EMA200", "EMA300"], highlight_data=highlight_data, title=f"{ticker} Closing Price and EMAs (Last 200 Periods) with Highlights")  # Adjust title as needed

"""Explanations:
When examining the behavior of moving averages, professionals often use specific terminology to describe their movement and patterns. Here's how they typically refer to the scenarios you've described:

(Spread Out EMAs): When the exponential moving averages (EMAs) are spread out from each other, it typically indicates a period of trending market or directional movement. This spread can suggest a strong move in the price, either upwards or downwards, depending on the direction of the EMAs. When EMAs separate widely, it's often referred to as divergence or fanning out in trading parlance. This can be a signal that the trend is strong and may continue.

(Bunched Up EMAs): Conversely, when EMAs come close together or converge, it often signifies a consolidation period or a low-volatility environment in the market. This bunched-up scenario is typically referred to as a convergence of moving averages or a compression. It might indicate indecision among traders or a balance between buyers and sellers. Compressions can sometimes precede a breakout or breakdown, as the market may be coiling before a significant move.

Understanding these patterns can be valuable for traders, as they may offer insights into market momentum and potential reversals. However, it's important to consider them in the context of other indicators and market conditions.

There are several indicators within TA-Lib that can help you analyze market conditions like the convergence and divergence of moving averages. Here are a few that might be useful:

ADX (Average Directional Movement Index): This indicator can help determine the strength of a trend. A rising ADX indicates a strong trend, while a falling ADX suggests a weakening trend or a period of consolidation.

Bollinger Bands (BBANDS): Bollinger Bands can be useful for identifying periods of low volatility when the bands contract and potential breakouts when the bands start to expand.

Standard Deviation (STDDEV): This can measure the spread of prices around the mean price, which can help in identifying periods of volatility compression and expansion.

ATR (Average True Range): The ATR is a volatility indicator that measures the degree of price volatility. Low ATR values can indicate a compression in price movement (similar to the EMAs bunching up), and higher values can indicate expansion.

CMO (Chande Momentum Oscillator): This oscillator can help identify the momentum of the market. During periods of compression where the EMAs bunch up, the CMO may hover near zero, indicating a lack of strong momentum.

ROC (Rate of change): This indicator measures the percentage change in price from one period to the next, which can help identify periods of increasing or decreasing momentum associated with diverging or converging EMAs.

Stochastic Oscillator (STOCH): Although you've excluded it from consideration, it's worth noting that the stochastic can be used to identify overbought and oversold conditions, which can occur at the extremes of EMA compression or divergence.

Williams %R (WILLR): Similar to the Stochastic Oscillator, this indicator can also identify overbought and oversold conditions which can sometimes correspond with the converging and diverging of EMAs.

By combining these indicators with the analysis of EMA patterns, you can gain a more comprehensive view of the market's behavior, allowing you to make more informed trading decisions.





"""

#@title MEGA candlesticks ( everything )
import yfinance as yf
import pandas as pd
import plotly.graph_objs as go
import talib
from datetime import datetime
import os

def download_data(ticker, period):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")
    return df

def add_all_candlestick_patterns(df):
    # Add all TA-Lib candlestick patterns
    pattern_names = talib.get_function_groups()['Pattern Recognition']

    for pattern in pattern_names:
        pattern_function = getattr(talib, pattern)
        df[pattern] = pattern_function(df['Open'], df['High'], df['Low'], df['Close'])

    return df

def plot_data(df, title):
    fig = go.Figure()

    fig.add_trace(go.Candlestick(x=df.index, open=df['Open'], high=df['High'], low=df['Low'], close=df['Close'], name='Market Data'))

    # Add each pattern to the chart
    for pattern in talib.get_function_groups()['Pattern Recognition']:
        fig.add_trace(go.Scatter(
            x=df.index,
            y=df[pattern],
            mode='markers',
            name=pattern
        ))

    fig.update_layout(title=title, xaxis_title='Date', yaxis_title='Price', height=800, width=1200)
    fig.show()

# Example usage:
#ticker = "NKE"  # Replace with desired ticker
ticker_data = download_data(ticker, period="2y")
ticker_data = add_all_candlestick_patterns(ticker_data)

# Plot data with technical indicators
plot_data(ticker_data, title=f"{ticker} Stock Analysis")

import sys
print('exiting anything under here needs debugging first ')
sys.exit('exiting!')

#@title Trend Line Analysis
import os
import yfinance as yf
import pandas as pd
import plotly.graph_objs as go
from datetime import datetime
from sympy import symbols, Eq, solve

# Function to download data and save to CSV

def download_dataOrig(ticker, period):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")
    return df



def download_data(ticker, period):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"data/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        df['Date'] = pd.to_datetime(df['Date'])  # Ensure 'Date' column is of datetime type
        df.set_index('Date', inplace=True)  # Set 'Date' as the index
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")
    return df

# Function to calculate the intersection date of trend lines
def calculate_intersection_date(highest_peak_last_six_months_date, highest_peak_last_six_months_value,
                                lowest_point_current_month_date, lowest_point_current_month_value):
    # Convert dates to ordinal numbers
    x1 = highest_peak_last_six_months_date.toordinal()
    x2 = lowest_point_current_month_date.toordinal()
    y1 = highest_peak_last_six_months_value
    y2 = lowest_point_current_month_value

    # Calculate slope and y-intercept for the trend line
    m_trend = (y2 - y1) / (x2 - x1)
    b_trend = y1 - m_trend * x1

    # Solve for the date at which the two lines are equal
    x = symbols('x')
    equation = Eq(m_trend * x + b_trend, m_trend * x + b_trend)
    intersection_x = solve(equation, x)

    # Convert the ordinal number back to a date
    if intersection_x:
        intersection_date = datetime.fromordinal(int(intersection_x[0]))
        return intersection_date
    else:
        return None

# Function to plot the data as candlestick charts using Plotly
def plot_data_as_candlesticks(df, ticker):
    # Create candlestick trace
    trace = go.Candlestick(
        x=df.index,
        open=df['Open'],
        high=df['High'],
        low=df['Low'],
        close=df['Close'],
        name='Candlesticks'
    )

    # Set up the Plotly figure
    fig = go.Figure(trace)

    # Find the highest peak in the last six months and add a trend line
    highest_peak_last_six_months_date = df.last('6M')['Close'].idxmax()
    highest_peak_last_six_months_value = df.last('6M')['Close'].max()

    fig.add_trace(go.Scatter(x=[highest_peak_last_six_months_date, df.index[-1]],
                             y=[highest_peak_last_six_months_value, df['Close'][-1]],
                             mode='lines', line=dict(color='red'), name='Trend Line - Peaks'))

    # Find the lowest trough in the current month and add a trend line
    lowest_point_current_month_date = df['Close'].idxmin()
    lowest_point_current_month_value = df['Close'].min()

    fig.add_trace(go.Scatter(x=[lowest_point_current_month_date, df.index[-1]],
                             y=[lowest_point_current_month_value, df['Close'][-1]],
                             mode='lines', line=dict(color='green'), name='Trend Line - Troughs'))

    # Add layout and show figure
    fig.update_layout(title=f"{ticker} Trend Line Analysis ", xaxis_title='Date', yaxis_title='Price')
    fig.show()

# Main function to run the analysis
def main():
    #ticker = "NVDA"  # Replace with desired ticker
    #period = "1y"
    df = download_data(ticker, period=myPeriod)
    plot_data_as_candlesticks(df, ticker)

if __name__ == '__main__':
    main()