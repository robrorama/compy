# -*- coding: utf-8 -*-
"""ok_talib.compile.and.so_many_things.tomaybeadd.derby_For_sharing_V16_fixed_NewPutCallGraphs_MAY_29_2024.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1iYgq5uMaP4THq9h0-1R34PdHFtlqNLq1

Later : pecentages for buy sell ratings . everything is cached
"""

ticker='spy'
period='1y'

#@title Download software
# Download the needed ta-lib software
#%%capture
import os
'''
if not os.path.exists('curl_ran.txt'):
  !curl -L http://prdownloads.sourceforge.net/ta-lib/ta-lib-0.4.0-src.tar.gz -O && tar xzvf ta-lib-0.4.0-src.tar.gz >curl_ran.txt
print('Downloaded package')
'''
'''
#@title Compile the software
# Download the needed ta-lib software ( note if you want to watch , comment out the %%capture with a hash mark)
#%%capture
import os
if not os.path.exists('compile_ran.txt'):
  !cd ta-lib && ./configure --prefix=/usr && make && make install && cd - >compile_ran.txt
print('compiled ta-lib')
'''
'''
#@title Install ta-lib wrappers
#%%capture
import os
if not os.path.exists('pip_ran.txt'):
  !pip install mplfinance
  !pip install numpy > pip_ran.txt
  !pip install scipy >> pip_ran.txt
  !pip install yfinance >>pip_ran.txt
  !pip install plotly >> pip_ran.txt
  !pip install ta-lib >> pip_ran.txt
  !pip install ta >>pip_ran.txt
print('installed ta-lib wrappers')
'''

import yfinance as yf
import pandas as pd
import plotly.graph_objs as go
from scipy.stats import linregress
#from scipy.stats import lingregress
from datetime import datetime
import os
import numpy as np



#@title Custom Number of Days Linear Regression curve with LRChannel
# Import necessary libraries
import yfinance as yf
import pandas as pd
import plotly.graph_objs as go
from scipy.stats import linregress
from datetime import datetime
import os
import numpy as np

# Function to download data from yfinance
def download_data(ticker, period):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")
    return df

# Function to add linear regression bands
def add_linear_regression_bands(df):
    df_numeric_index = pd.to_numeric(df.index)

    slope, intercept, _, _, _ = linregress(df_numeric_index, df['Close'])
    #slope, intercept, _, _, _ = linregress(df_numeric_index, df['Close'])
    df['Linear_Reg'] = intercept + slope * df_numeric_index
    df['Residuals'] = df['Close'] - df['Linear_Reg']
    residuals_std = df['Residuals'].std()

    desired_values = [.5, 1, 1.25, 1.5, 1.75, 2, 2.25, 3, 4]

    for i, num_std in enumerate(desired_values):
        df[f'Reg_High_{i+1}std'] = df['Linear_Reg'] + residuals_std * num_std
        df[f'Reg_Low_{i+1}std'] = df['Linear_Reg'] - residuals_std * num_std

    return df



# Function to add high volatility detection
def add_high_volatility(df, atr_length=14, atr_multiplier=2):
    df['High-Low'] = df['High'] - df['Low']
    df['High-Close'] = np.abs(df['High'] - df['Close'].shift())
    df['Low-Close'] = np.abs(df['Low'] - df['Close'].shift())
    df['TR'] = df[['High-Low', 'High-Close', 'Low-Close']].max(axis=1)
    df['ATR'] = df['TR'].rolling(window=atr_length).mean()

    # High Volatility condition
    df['High_Volatility'] = df['High-Low'] > atr_multiplier * df['ATR']
    return df

# Function to add volume spike detection
def add_volume_spikes(df, volume_ma_length=20, spike_threshold=2):
    df['Volume_MA'] = df['Volume'].rolling(window=volume_ma_length).mean()

    # Volume Spike condition
    df['Volume_Spike'] = df['Volume'] > spike_threshold * df['Volume_MA']
    return df

# Function to add linear regression curve
def add_linear_regression_curve(df, window=20, curve_color='cyan'):
    def linear_reg_slope_intercept(y_values):
        x_values = np.arange(len(y_values))
        slope, intercept, _, _, _ = linregress(x_values, y_values)
        return slope, intercept

    # Calculate slope and intercept for rolling window
    rolling_slope_intercept = df['Close'].rolling(window=window).apply(
        lambda x: linear_reg_slope_intercept(x)[0] * (window - 1) + linear_reg_slope_intercept(x)[1], raw=False)

    df['Linear_Reg_Curve'] = rolling_slope_intercept
    return df, curve_color


# Plotting function
def plot_data(df, title):
    fig = go.Figure()

    # Plot Candlestick chart
    fig.add_trace(go.Candlestick(x=df.index, open=df['Open'], high=df['High'], low=df['Low'], close=df['Close'], name='Market Data'))

    # Plot Linear Regression and its bands
    fig.add_trace(go.Scatter(x=df.index, y=df['Linear_Reg'], line=dict(color='blue', width=2), name='Linear Regression'))
    colors = ['grey', 'green', 'orange', 'red', 'purple', 'brown', 'pink', 'gray', 'blue']  # Add more colors as needed
    desired_values = [.5, 1, 1.25, 1.5, 1.75, 2, 2.25, 3, 4]
    for i, num_std in enumerate(desired_values):
        fig.add_trace(go.Scatter(
            x=df.index,
            y=df[f'Reg_High_{i+1}std'],
            line=dict(color=colors[i], width=1, dash='dot'),
            name=f'Reg High {num_std} std'
        ))
        fig.add_trace(go.Scatter(
            x=df.index,
            y=df[f'Reg_Low_{i+1}std'],
            line=dict(color=colors[i], width=1, dash='dot'),
            name=f'Reg Low {num_std} std'
        ))

    # Plot High Volatility Markers
    fig.add_trace(go.Scatter(
        x=df.index,
        y=df[df['High_Volatility']]['High'],  # Plot where high volatility is True
        mode='markers',
        marker=dict(color='purple', size=10),
        name='High Volatility'
    ))

    # Plot Volume Spike Markers
    fig.add_trace(go.Scatter(
        x=df.index,
        y=df[df['Volume_Spike']]['High'],  # Plot where volume spike is True
        mode='markers',
        marker=dict(color='orange', size=10),
        name='Volume Spike'
    ))

    # Plot X-day Linear Regression Curve
    fig.add_trace(go.Scatter(
        x=df.index,
        y=df['Linear_Reg_Curve'],
        line=dict(color=curve_color, width=2),
        name=f'{window}-day Linear Regression Curve'
    ))

    # Update layout
    fig.update_layout(title=title, xaxis_title='Date', yaxis_title='Price', height=800, width=1200)
    fig.show()

# Main workflow
#ticker = "save"  # Replace with desired ticker
window = 20 # change linear regression curve value here
curve_color='green'
ticker_data = download_data(ticker, period=period)
ticker_data = add_linear_regression_bands(ticker_data)
ticker_data = add_high_volatility(ticker_data)
ticker_data = add_volume_spikes(ticker_data)
#ticker_data = add_linear_regression_curve(ticker_data)  # Add the Linear Regression Curve
ticker_data, curve_color = add_linear_regression_curve(ticker_data, window, curve_color)

# Plot data with technical indicators
plot_data(ticker_data, title=f"{ticker} Linear Regression Channels with {window}-Day Linear Regresion Curve")

#@title Download initial Data

import yfinance as yf
import pandas as pd
import plotly.graph_objs as go
from scipy.stats import linregress
from datetime import datetime
import os
#ticker='leave me commented out'
def download_data(ticker, period):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")
    return df



# Example usage:
ticker_data = download_data(ticker, period=period)
print(f"finished downloading data for {ticker}")

#@title Plot Linear Regression Channel
import yfinance as yf
import pandas as pd
import plotly.graph_objs as go
from scipy.stats import linregress
from datetime import datetime
import os

def download_data(ticker, period):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")
    return df

def add_linear_regression_bands(df):
    df_numeric_index = pd.to_numeric(df.index)
    slope, intercept, _, _, _ = linregress(df_numeric_index, df['Close'])
    df['Linear_Reg'] = intercept + slope * df_numeric_index
    df['Residuals'] = df['Close'] - df['Linear_Reg']
    residuals_std = df['Residuals'].std()

    desired_values = [.5, 1, 1.25, 1.5, 1.75, 2, 2.25, 3, 4]

    for i, num_std in enumerate(desired_values):
        df[f'Reg_High_{i+1}std'] = df['Linear_Reg'] + residuals_std * num_std
        df[f'Reg_Low_{i+1}std'] = df['Linear_Reg'] - residuals_std * num_std

    return df

def plot_data(df, title):
    fig = go.Figure()

    # Define desired_values within the plot_data function
    desired_values = [.5, 1, 1.25, 1.5, 1.75, 2, 2.25, 3, 4]


    fig.add_trace(go.Candlestick(x=df.index, open=df['Open'], high=df['High'], low=df['Low'], close=df['Close'], name='Market Data'))

    fig.add_trace(go.Scatter(x=df.index, y=df['Linear_Reg'], line=dict(color='blue', width=2), name='Linear Regression'))
    colors = ['grey', 'green', 'orange', 'red', 'purple', 'brown', 'pink', 'gray', 'blue']  # Add more colors as needed
    for i, num_std in enumerate(desired_values):
        fig.add_trace(go.Scatter(
            x=df.index,
            y=df[f'Reg_High_{i+1}std'],
            line=dict(color=colors[i], width=1, dash='dot'),
            name=f'Reg High {num_std} std'
        ))
        fig.add_trace(go.Scatter(
            x=df.index,
            y=df[f'Reg_Low_{i+1}std'],
            line=dict(color=colors[i], width=1, dash='dot'),
            name=f'Reg Low {num_std} std'
        ))

    fig.update_layout(title=title, xaxis_title='Date', yaxis_title='Price', height=800, width=1200)
    fig.show()

# Example usage:
#ticker = "NKE"  # Replace with desired ticker
ticker_data = download_data(ticker, period=period)
ticker_data = add_linear_regression_bands(ticker_data)

# Plot data with technical indicators
plot_data(ticker_data, title=f"{ticker} Linear Regression Channel and CandleSticks")

#@title : EMAs :
import yfinance as yf
import pandas as pd
import plotly.graph_objs as go
from scipy.stats import linregress
from datetime import datetime
import os

def download_data(ticker, period):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")
    return df

def add_linear_regression_bands(df):
    df_numeric_index = pd.to_numeric(df.index)
    slope, intercept, _, _, _ = linregress(df_numeric_index, df['Close'])
    df['Linear_Reg'] = intercept + slope * df_numeric_index
    df['Residuals'] = df['Close'] - df['Linear_Reg']
    residuals_std = df['Residuals'].std()

    desired_values = [.5, 1, 1.25, 1.5, 1.75, 2, 2.25, 3, 4]
    for i, num_std in enumerate(desired_values):
        df[f'Reg_High_{i+1}std'] = df['Linear_Reg'] + residuals_std * num_std
        df[f'Reg_Low_{i+1}std'] = df['Linear_Reg'] - residuals_std * num_std
    return df

def add_ema(df, time_periods):
    for time_period in time_periods:
        df[f'EMA_{time_period}'] = df['Close'].ewm(span=time_period, adjust=False).mean()
    return df

def plot_data(df, title):
    fig = go.Figure()

    desired_values = [.5, 1, 1.25, 1.5, 1.75, 2, 2.25, 3, 4]
    fig.add_trace(go.Candlestick(x=df.index, open=df['Open'], high=df['High'], low=df['Low'], close=df['Close'], name='Market Data'))
    fig.add_trace(go.Scatter(x=df.index, y=df['Linear_Reg'], line=dict(color='blue', width=2), name='Linear Regression'))

    colors = ['grey', 'green', 'orange', 'red', 'purple', 'brown', 'pink', 'gray', 'blue']
    for i, num_std in enumerate(desired_values):
        fig.add_trace(go.Scatter(x=df.index, y=df[f'Reg_High_{i+1}std'], line=dict(color=colors[i], width=1, dash='dot'), name=f'Reg High {num_std} std'))
        fig.add_trace(go.Scatter(x=df.index, y=df[f'Reg_Low_{i+1}std'], line=dict(color=colors[i], width=1, dash='dot'), name=f'Reg Low {num_std} std'))

    ema_colors = ['purple', 'orange', 'green', 'red', 'blue']
    for i, time_period in enumerate([20, 50, 100, 200, 300]):
        fig.add_trace(go.Scatter(x=df.index, y=df[f'EMA_{time_period}'], line=dict(color=ema_colors[i], width=2), name=f'{time_period}-day EMA'))

    fig.update_layout(title=title, xaxis_title='Date', yaxis_title='Price', height=800, width=1200)
    fig.show()

# Example usage:
#ticker = "NKE"  # Replace with desired ticker
#period = "1y"
ticker_data = download_data(ticker, period)
ticker_data = add_linear_regression_bands(ticker_data)
ticker_data = add_ema(ticker_data, [20, 50, 100, 200, 300])

# Plot data with technical indicators
plot_data(ticker_data, title=f"{ticker} Linear Regression Channel, CandleSticks, and EMAs")

#@title : relative to the sector : retire thsi one i do not like how it dsiplays, the next one is better
import yfinance as yf
import pandas as pd
import plotly.graph_objs as go
from scipy.stats import linregress
from datetime import datetime
import os

def download_data(ticker, sector_ticker, period):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}.csv"
    sector_data_file = f"{data_dir}/{sector_ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        sector_df = pd.read_csv(sector_data_file)
        print(f"Data for {ticker} and {sector_ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        sector_df = yf.download(sector_ticker, period=period)
        df.to_csv(data_file)
        sector_df.to_csv(sector_data_file)
        print(f"Data for {ticker} and {sector_ticker} downloaded and saved to disk.")
    return df, sector_df

def add_linear_regression_bands(df):
    df_numeric_index = pd.to_numeric(df.index)
    slope, intercept, _, _, _ = linregress(df_numeric_index, df['Close'])
    df['Linear_Reg'] = intercept + slope * df_numeric_index
    df['Residuals'] = df['Close'] - df['Linear_Reg']
    residuals_std = df['Residuals'].std()

    desired_values = [.5, 1, 1.25, 1.5, 1.75, 2, 2.25, 3, 4]
    for i, num_std in enumerate(desired_values):
        df[f'Reg_High_{i+1}std'] = df['Linear_Reg'] + residuals_std * num_std
        df[f'Reg_Low_{i+1}std'] = df['Linear_Reg'] - residuals_std * num_std
    return df

def add_ema(df, time_periods):
    for time_period in time_periods:
        df[f'EMA_{time_period}'] = df['Close'].ewm(span=time_period, adjust=False).mean()
    return df

def plot_data(df, sector_df, title):
    fig = go.Figure()

    desired_values = [.5, 1, 1.25, 1.5, 1.75, 2, 2.25, 3, 4]
    fig.add_trace(go.Candlestick(x=df.index, open=df['Open'], high=df['High'], low=df['Low'], close=df['Close'], name='Stock Data'))
    fig.add_trace(go.Candlestick(x=sector_df.index, open=sector_df['Open'], high=sector_df['High'], low=sector_df['Low'], close=sector_df['Close'], name='Sector Data'))

    fig.add_trace(go.Scatter(x=df.index, y=df['Linear_Reg'], line=dict(color='blue', width=2), name='Linear Regression'))

    colors = ['grey', 'green', 'orange', 'red', 'purple', 'brown', 'pink', 'gray', 'blue']
    for i, num_std in enumerate(desired_values):
        fig.add_trace(go.Scatter(x=df.index, y=df[f'Reg_High_{i+1}std'], line=dict(color=colors[i], width=1, dash='dot'), name=f'Reg High {num_std} std'))
        fig.add_trace(go.Scatter(x=df.index, y=df[f'Reg_Low_{i+1}std'], line=dict(color=colors[i], width=1, dash='dot'), name=f'Reg Low {num_std} std'))

    ema_colors = ['purple', 'orange', 'green', 'red', 'blue']
    for i, time_period in enumerate([20, 50, 100, 200, 300]):
        fig.add_trace(go.Scatter(x=df.index, y=df[f'EMA_{time_period}'], line=dict(color=ema_colors[i], width=2), name=f'{time_period}-day EMA'))

    fig.update_layout(title=title, xaxis_title='Date', yaxis_title='Price', height=800, width=1200)
    fig.show()

# Example usage:
#ticker = "XOM"  # Replace with desired stock ticker
sector_ticker = "spy"  # Replace with desired sector ticker
#period = "10y"
stock_data, sector_data = download_data(ticker, sector_ticker, period)
stock_data = add_linear_regression_bands(stock_data)
stock_data = add_ema(stock_data, [20, 50, 100, 200, 300])

# Plot data with technical indicators
plot_data(stock_data, sector_data, title=f"{ticker} vs {sector_ticker} Linear Regression Channel, CandleSticks, and EMAs")

#@title relative to sector fixed :
import yfinance as yf
import pandas as pd
import plotly.graph_objs as go
from scipy.stats import linregress
from datetime import datetime
import os

def download_data(ticker, sector_ticker, period):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}.csv"
    sector_data_file = f"{data_dir}/{sector_ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        sector_df = pd.read_csv(sector_data_file)
        print(f"Data for {ticker} and {sector_ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        sector_df = yf.download(sector_ticker, period=period)
        df.to_csv(data_file)
        sector_df.to_csv(sector_data_file)
        print(f"Data for {ticker} and {sector_ticker} downloaded and saved to disk.")
    return df, sector_df

def calculate_relative_performance(stock_data, sector_data):
    relative_data = pd.DataFrame(index=stock_data.index)
    relative_data['Relative'] = stock_data['Close'] / sector_data['Close']
    return relative_data

def add_linear_regression_bands(df):
    df_numeric_index = pd.to_numeric(df.index)
    slope, intercept, _, _, _ = linregress(df_numeric_index, df['Relative'])
    df['Linear_Reg'] = intercept + slope * df_numeric_index
    df['Residuals'] = df['Relative'] - df['Linear_Reg']
    residuals_std = df['Residuals'].std()

    desired_values = [.5, 1, 1.25, 1.5, 1.75, 2, 2.25, 3, 4]
    for i, num_std in enumerate(desired_values):
        df[f'Reg_High_{i+1}std'] = df['Linear_Reg'] + residuals_std * num_std
        df[f'Reg_Low_{i+1}std'] = df['Linear_Reg'] - residuals_std * num_std
    return df

def add_ema(df, time_periods):
    for time_period in time_periods:
        df[f'EMA_{time_period}'] = df['Relative'].ewm(span=time_period, adjust=False).mean()
    return df

def plot_data(df, title):
    fig = go.Figure()

    desired_values = [.5, 1, 1.25, 1.5, 1.75, 2, 2.25, 3, 4]
    fig.add_trace(go.Scatter(x=df.index, y=df['Relative'], name='Relative Performance'))
    fig.add_trace(go.Scatter(x=df.index, y=df['Linear_Reg'], line=dict(color='blue', width=2), name='Linear Regression'))

    colors = ['grey', 'green', 'orange', 'red', 'purple', 'brown', 'pink', 'gray', 'blue']
    for i, num_std in enumerate(desired_values):
        fig.add_trace(go.Scatter(x=df.index, y=df[f'Reg_High_{i+1}std'], line=dict(color=colors[i], width=1, dash='dot'), name=f'Reg High {num_std} std'))
        fig.add_trace(go.Scatter(x=df.index, y=df[f'Reg_Low_{i+1}std'], line=dict(color=colors[i], width=1, dash='dot'), name=f'Reg Low {num_std} std'))

    ema_colors = ['purple', 'orange', 'green', 'red', 'blue']
    for i, time_period in enumerate([20, 50, 100, 200, 300]):
        fig.add_trace(go.Scatter(x=df.index, y=df[f'EMA_{time_period}'], line=dict(color=ema_colors[i], width=2), name=f'{time_period}-day EMA'))

    fig.update_layout(title=title, xaxis_title='Date', yaxis_title='Relative Performance', height=800, width=1200)
    fig.show()

# Example usage:
#ticker = "XOM"  # Replace with desired stock ticker
sector_ticker = "SPY"  # Replace with desired sector ticker
#period = "1y"
stock_data, sector_data = download_data(ticker, sector_ticker, period)
relative_data = calculate_relative_performance(stock_data, sector_data)
relative_data = add_linear_regression_bands(relative_data)
relative_data = add_ema(relative_data, [20, 50, 100, 200, 300])

# Plot data with technical indicators
plot_data(relative_data, title=f"{ticker} Relative Performance to {sector_ticker}")

#@title Bollinger Bands, Volume, MACD, Stochastic, RSI
# Download the needed ta-lib software
import yfinance as yf
import pandas as pd
import plotly.graph_objs as go
import plotly.subplots
from ta.trend import MACD
from ta.momentum import StochasticOscillator, RSIIndicator
from datetime import datetime
import os

def download_data(ticker, period):
    """Downloads data from yfinance for the specified ticker and period."""
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)

    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")

    return df

def add_technical_indicators(df):
    """Adds moving averages, MACD, Stochastic, RSI, and Bollinger Bands to the DataFrame."""
    for span in [50, 100, 150, 200, 300]:
        df[f'MA{span}'] = df['Close'].rolling(window=span).mean()

    # MACD
    macd = MACD(close=df['Close'])
    df['MACD'] = macd.macd()
    df['MACD_Signal'] = macd.macd_signal()
    df['MACD_Diff'] = macd.macd_diff()

    # Stochastic Oscillator
    stoch = StochasticOscillator(high=df['High'], close=df['Close'], low=df['Low'])
    df['Stoch'] = stoch.stoch()
    df['Stoch_Signal'] = stoch.stoch_signal()

    # RSI
    rsi = RSIIndicator(close=df['Close'])
    df['RSI'] = rsi.rsi()

    # Bollinger Bands
    moving_average = df['Close'].rolling(window=20).mean()
    moving_std_dev = df['Close'].rolling(window=20).std()
    df['Bollinger_High'] = moving_average + (moving_std_dev * 2)
    df['Bollinger_Low'] = moving_average - (moving_std_dev * 2)

    return df

def plot_data(df, title):
    """Plots the DataFrame using Plotly with subplots for different indicators."""
    ## Initialize subplots
    ##fig = plotly.subplots.make_subplots(rows=5, cols=1, shared_xaxes=True, vertical_spacing=0.01)
    # Initialize subplots with custom heights
    fig = plotly.subplots.make_subplots(
    rows=5, cols=1, shared_xaxes=True,
    vertical_spacing=0.02,  # Adjust spacing to your preference
    subplot_titles=("Stock Data", "MACD", "Volume", "Stochastic", "RSI"),
    row_heights=[0.1, 0.03, 0.03, 0.03, 0.03])


    # Candlestick chart
    fig.add_trace(go.Candlestick(x=df.index, open=df['Open'], high=df['High'], low=df['Low'], close=df['Close'], name='Market Data'), row=1, col=1)

    # Moving Averages and Bollinger Bands
    #for span in [50, 100, 150, 200, 300]:
    #    fig.add_trace(go.Scatter(x=df.index, y=df[f'MA{span}'], opacity=0.7, name=f'MA {span}'), row=1, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['Bollinger_High'], line=dict(color='black', width=1), name='Bollinger High'), row=1, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['Bollinger_Low'], line=dict(color='black', width=1), name='Bollinger Low'), row=1, col=1)


    # MACD
    colors = ['green' if val >= 0 else 'red' for val in df['MACD_Diff']]
    fig.add_trace(go.Bar(x=df.index, y=df['MACD_Diff'], marker_color=colors), row=2, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['MACD'], line=dict(color='red', width=2)), row=2, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['MACD_Signal'], line=dict(color='blue', width=2)), row=2, col=1)


    # Volume
    colors = ['green' if row['Open'] - row['Close'] >= 0 else 'red' for index, row in df.iterrows()]
    fig.add_trace(go.Bar(x=df.index, y=df['Volume'], marker_color=colors), row=3, col=1)

    # Stochastic Oscillator
    fig.add_trace(go.Scatter(x=df.index, y=df['Stoch'], line=dict(color='black', width=1)), row=4, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['Stoch_Signal'], line=dict(color='blue', width=1)), row=4, col=1)

    # RSI
    fig.add_trace(go.Scatter(x=df.index, y=df['RSI'], line=dict(color='purple', width=1)), row=5, col=1)

    # Update layout
    ##fig.update_layout(height=1200, width=1200, showlegend=False, xaxis_rangeslider_visible=False)
    fig.update_layout(height=1500, width=1200, showlegend=False, xaxis_rangeslider_visible=False)
    fig.update_yaxes(title_text="Price", row=1, col=1)
    fig.update_yaxes(title_text="MACD", showgrid=False, row=2, col=1)
    fig.update_yaxes(title_text="Volume", row=3, col=1)
    fig.update_yaxes(title_text="Stochastic", row=4, col=1)
    fig.update_yaxes(title_text="RSI", row=5, col=1)

    fig.show()

# Example usage:
#ticker = "qqq"  # Replace with desired ticker
ticker_data = download_data(ticker, period=period)
ticker_data = add_technical_indicators(ticker_data)

# Plot data with technical indicators
plot_data(ticker_data, title=f"{ticker} Stock Analysis")

#ichimoku:
import yfinance as yf
import pandas as pd
import os
from datetime import datetime
import mplfinance as mpf

# Define the stock symbol and time period
symbol = ticker
period = period

def download_data(ticker, period):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"cached_data/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file, index_col='Date', parse_dates=True)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")
    return df

def calculate_ichimoku(df):
    # Calculate Ichimoku Cloud
    df['Tenkan-sen'] = (df['High'].rolling(window=9).max() + df['Low'].rolling(window=9).min()) / 2
    df['Kijun-sen'] = (df['High'].rolling(window=26).max() + df['Low'].rolling(window=26).min()) / 2
    df['Senkou_Span_A'] = (df['Tenkan-sen'] + df['Kijun-sen']) / 2
    df['Senkou_Span_B'] = (df['High'].rolling(window=52).max() + df['Low'].rolling(window=52).min()) / 2
    df['Chikou_Span'] = df['Close'].shift(periods=-26)
    return df

# Download and calculate Ichimoku Cloud
data = download_data(symbol, period)
data = calculate_ichimoku(data)

# Create addplot data
ic = [
    mpf.make_addplot(data['Tenkan-sen'], color='#fcc905', alpha=0.5),
    mpf.make_addplot(data['Kijun-sen'], color='#F83C78', alpha=0.5),
    mpf.make_addplot(data['Chikou_Span'], color='#8D8D16', alpha=0.8),
    mpf.make_addplot(data['Senkou_Span_A'], color='#006B3D', alpha=0.8),
    mpf.make_addplot(data['Senkou_Span_B'], color='#D3212C', alpha=0.8)
]

# Define fill between areas
ichimoko_fill_up = dict(y1=data['Senkou_Span_A'].values, y2=data['Senkou_Span_B'].values, where=data['Senkou_Span_A'] >= data['Senkou_Span_B'], alpha=0.5, color='#a6f7a6')
ichimoko_fill_down = dict(y1=data['Senkou_Span_A'].values, y2=data['Senkou_Span_B'].values, where=data['Senkou_Span_A'] < data['Senkou_Span_B'], alpha=0.5, color='#FC8EAC')

# Plot the data
mpf.plot(
    data,
    volume=True,
    type="candle",
    fill_between=[ichimoko_fill_up, ichimoko_fill_down],
    style="yahoo",
    addplot=ic,
    figsize=(20, 10)
)

#@title EMAs
import yfinance as yf
import pandas as pd
import plotly.graph_objs as go
import os
from datetime import datetime

def download_data(ticker, period):
    """Downloads data from yfinance for the specified ticker and period,
       saving it to a local directory structure."""
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)

    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")

    return df

def calculate_emas(df, spans):
    """Calculates Exponential Moving Averages (EMAs) for the given DataFrame and spans."""
    for span in spans:
        df[f"EMA{span}"] = df["Close"].ewm(span=span, adjust=False).mean()
    return df

def plot_data(df, title=""):
    """Plots the DataFrame using Plotly."""
    fig = go.Figure()

    # Plot Close price and EMAs
    fig.add_trace(go.Scatter(x=df.index, y=df['Close'], mode='lines', name='Close'))
    for span in [50, 100, 150, 200, 300]:
        fig.add_trace(go.Scatter(x=df.index, y=df[f'EMA{span}'], mode='lines', name=f'EMA{span}'))

    # Highlight the high and low points for the last 200 and 30 periods
    last_200_periods = df.iloc[-200:]
    last_30_periods = df.iloc[-30:]

    max_200 = last_200_periods['Close'].idxmax()
    min_200 = last_200_periods['Close'].idxmin()
    max_30 = last_30_periods['Close'].idxmax()
    min_30 = last_30_periods['Close'].idxmin()

    fig.add_trace(go.Scatter(x=[max_200], y=[last_200_periods['Close'].max()], mode='markers', marker=dict(color='green', size=10), name='High (200)'))
    fig.add_trace(go.Scatter(x=[min_200], y=[last_200_periods['Close'].min()], mode='markers', marker=dict(color='red', size=10), name='Low (200)'))
    fig.add_trace(go.Scatter(x=[max_30], y=[last_30_periods['Close'].max()], mode='markers', marker=dict(color='blue', size=10), name='High (30)'))
    fig.add_trace(go.Scatter(x=[min_30], y=[last_30_periods['Close'].min()], mode='markers', marker=dict(color='orange', size=10), name='Low (30)'))

    # Customize layout
    fig.update_layout(title=title, xaxis_title='Date', yaxis_title='Price', template='plotly_dark')

    fig.show()

# Example usage:
#ticker = "NKE"  # Replace "NKE" with your desired ticker symbol
ticker_data = download_data(ticker, period=period)
ticker_data = calculate_emas(ticker_data, spans=[50, 100, 150, 200, 300])

# Plot data with highlights
plot_data(ticker_data, title=f"{ticker} Closing Price and EMAs with Highlights")

#@title Linear Regression Curves
# Import necessary libraries
import yfinance as yf
import pandas as pd
import plotly.graph_objs as go
import os
from datetime import datetime
import numpy as np
from scipy.stats import linregress

def download_data(ticker, period):
    """Downloads data from yfinance for the specified ticker and period,
       saving it to a local directory structure."""
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)

    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")

    return df

def calculate_linear_regression_curves(df, spans):
    """Calculates Linear Regression Curves for the given DataFrame and spans."""
    for span in spans:
        df, curve_color = add_linear_regression_curve(df, window=span, curve_color=f'Linear_Regression_{span}')
    return df

def add_linear_regression_curve(df, window=20, curve_color='cyan'):
    def linear_reg_slope_intercept(y_values):
        x_values = np.arange(len(y_values))
        slope, intercept, _, _, _ = linregress(x_values, y_values)
        return slope, intercept

    # Calculate slope and intercept for rolling window
    rolling_slope_intercept = df['Close'].rolling(window=window).apply(
        lambda x: linear_reg_slope_intercept(x)[0] * (window - 1) + linear_reg_slope_intercept(x)[1], raw=False)

    df[f'Linear_Regression_{window}'] = rolling_slope_intercept
    return df, curve_color

def plot_data(df, title=""):
    """Plots the DataFrame using Plotly."""
    fig = go.Figure()

    # Plot Close price and Linear Regression Curves
    fig.add_trace(go.Scatter(x=df.index, y=df['Close'], mode='lines', name='Close'))
    #for span in [12, 20, 50, 100, 150, 200, 300]:
    for span in [12, 20, 50, 100, 150]:
        fig.add_trace(go.Scatter(x=df.index, y=df[f'Linear_Regression_{span}'], mode='lines', name=f'Linear Regression {span}'))

    # Customize layout
    fig.update_layout(title=title, xaxis_title='Date', yaxis_title='Price', template='plotly_dark')

    fig.show()

# Example usage:
#ticker = "DIS"  # Replace "NKE" with your desired ticker symbol
ticker_data = download_data(ticker, period=period)

# Calculate Linear Regression Curves for the specified time frames
#ticker_data = calculate_linear_regression_curves(ticker_data, spans=[12, 20, 50, 100, 150, 200, 300])

ticker_data = calculate_linear_regression_curves(ticker_data, spans=[12, 20, 50, 100, 150])

# Plot data with Linear Regression Curves
plot_data(ticker_data, title=f"{ticker} Closing Price and Linear Regression Curves")

#@title MULTI-INDICATORS # USES CACHING
import yfinance as yf
import pandas as pd
import plotly.graph_objs as go
from plotly.subplots import make_subplots
import os
from datetime import datetime
import talib

def download_data(ticker, period):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")
    return df

def calculate_indicators(df):
    # Calculate EMAs
    for span in [50, 100, 150, 200, 300]:
        df[f'EMA{span}'] = df['Close'].ewm(span=span, adjust=False).mean()

    # Calculate Bollinger Bands
    upperband, middleband, lowerband = talib.BBANDS(df['Close'], timeperiod=20, nbdevup=2, nbdevdn=2, matype=0)
    df['upperband'] = upperband
    df['middleband'] = middleband
    df['lowerband'] = lowerband

    # Calculate other indicators
    df['ADX'] = talib.ADX(df['High'], df['Low'], df['Close'], timeperiod=14)
    df['STDDEV'] = talib.STDDEV(df['Close'], timeperiod=5, nbdev=1)
    df['ATR'] = talib.ATR(df['High'], df['Low'], df['Close'], timeperiod=14)
    df['CMO'] = talib.CMO(df['Close'], timeperiod=14)
    df['ROC'] = talib.ROC(df['Close'], timeperiod=10)
    df['STOCH_k'], df['STOCH_d'] = talib.STOCH(df['High'], df['Low'], df['Close'])
    df['WILLR'] = talib.WILLR(df['High'], df['Low'], df['Close'], timeperiod=14)


    # Calculate Linear Regression Slope
    window = 14  # You can adjust the window period as needed
    df['LR_Slope'] = talib.LINEARREG_SLOPE(df['Close'], timeperiod=window)

    return df

def plot_data(df, title):
    # Create a subplot for each indicator with varying heights
    fig = make_subplots(rows=9, cols=1, shared_xaxes=True,
                        vertical_spacing=0.02,
                        subplot_titles=('Bollinger Bands', 'ADX', 'STDDEV', 'ATR', 'CMO', 'ROC', 'Stochastic', 'Williams %R', 'LR Slope'),
                        row_heights=[0.2, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05])

    # Plot Close price and Bollinger Bands with colors
    fig.add_trace(go.Scatter(x=df.index, y=df['Close'], mode='lines', name='Close', line=dict(color='blue', width=2)), row=1, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['upperband'], mode='lines', name='Upper Band', line=dict(color='green', width=1)), row=1, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['middleband'], mode='lines', name='Middle Band', line=dict(color='white', width=1)), row=1, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['lowerband'], mode='lines', name='Lower Band', line=dict(color='red', width=1)), row=1, col=1)

    # Plot other indicators in subplots with colors
    fig.add_trace(go.Scatter(x=df.index, y=df['ADX'], mode='lines', name='ADX', line=dict(color='lawngreen', width=1)), row=2, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['STDDEV'], mode='lines', name='STDDEV', line=dict(color='magenta', width=1)), row=3, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['ATR'], mode='lines', name='ATR', line=dict(color='blue', width=1)), row=4, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['CMO'], mode='lines', name='CMO', line=dict(color='red', width=1)), row=5, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['ROC'], mode='lines', name='ROC', line=dict(color='lime', width=1)), row=6, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['WILLR'], mode='lines', name='Williams %R', line=dict(color='cyan', width=1)), row=7, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['STOCH_k'], mode='lines', name='STOCH_k', line=dict(color='red', width=1)), row=8, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['STOCH_d'], mode='lines', name='STOCH_d', line=dict(color='blue', width=1)), row=8, col=1)

    # Add subplot for Linear Regression Slope
    fig.add_trace(go.Scatter(x=df.index, y=df['LR_Slope'], mode='lines', name='LR Slope', line=dict(color='yellow', width=1)), row=9, col=1)

    # Customize layout
    fig.update_layout(title=title, xaxis_title='Date', yaxis_title='Price', template='plotly_dark', height=2000, showlegend=False)

    # Customize y-axis labels for subplots
    fig.update_yaxes(title_text="Price", row=1, col=1)
    fig.update_yaxes(title_text="ADX", row=2, col=1)
    fig.update_yaxes(title_text="STDDEV", row=3, col=1)
    fig.update_yaxes(title_text="ATR", row=4, col=1)
    fig.update_yaxes(title_text="CMO", row=5, col=1)
    fig.update_yaxes(title_text="ROC", row=6, col=1)
    fig.update_yaxes(title_text="Williams %R", row=7, col=1)
    fig.update_yaxes(title_text="Stochastic", row=8, col=1)
    fig.update_yaxes(title_text="LR Slope", row=9, col=1)

    fig.show()

# Example usage:
# ticker = "AAPL"  # Replace with your desired ticker symbol
ticker_data = download_data(ticker, period=period)
ticker_data = calculate_indicators(ticker_data)
plot_data(ticker_data, title=f"{ticker} Stock Data with Technical Indicators")

## NEW UP ONE :
import yfinance as yf
import pandas as pd
import plotly.graph_objs as go
from plotly.subplots import make_subplots
import os
from datetime import datetime
import talib

def download_data(ticker, period):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")
    return df

def calculate_indicators(df):
    # Existing indicators calculation
    for span in [50, 100, 150, 200, 300]:
        df[f'EMA{span}'] = df['Close'].ewm(span=span, adjust=False).mean()

    upperband, middleband, lowerband = talib.BBANDS(df['Close'], timeperiod=20, nbdevup=2, nbdevdn=2, matype=0)
    df['upperband'] = upperband
    df['middleband'] = middleband
    df['lowerband'] = lowerband

    df['ADX'] = talib.ADX(df['High'], df['Low'], df['Close'], timeperiod=14)
    df['STDDEV'] = talib.STDDEV(df['Close'], timeperiod=5, nbdev=1)
    df['ATR'] = talib.ATR(df['High'], df['Low'], df['Close'], timeperiod=14)
    df['CMO'] = talib.CMO(df['Close'], timeperiod=14)
    df['ROC'] = talib.ROC(df['Close'], timeperiod=10)
    df['STOCH_k'], df['STOCH_d'] = talib.STOCH(df['High'], df['Low'], df['Close'])
    df['WILLR'] = talib.WILLR(df['High'], df['Low'], df['Close'], timeperiod=14)

    # Calculate Linear Regression Slope
    window = 14  # You can adjust the window period as needed
    df['LR_Slope'] = talib.LINEARREG_SLOPE(df['Close'], timeperiod=window)

    #window = 14
    #df['LR_Slope'] = talib.LINEARREG_SLOPE(df['Close'], timeperiod=window)

    # New indicators calculation
    df['RSI'] = talib.RSI(df['Close'], timeperiod=14)
    df['MACD'], df['MACDSIGNAL'], df['MACDHIST'] = talib.MACD(df['Close'], fastperiod=12, slowperiod=26, signalperiod=9)
    df['OBV'] = talib.OBV(df['Close'], df['Volume'])
    df['SAR'] = talib.SAR(df['High'], df['Low'], acceleration=0.02, maximum=0.2)
    df['ULTOSC'] = talib.ULTOSC(df['High'], df['Low'], df['Close'], timeperiod1=7, timeperiod2=14, timeperiod3=28)
    df['MFI'] = talib.MFI(df['High'], df['Low'], df['Close'], df['Volume'], timeperiod=14)
    df['CCI'] = talib.CCI(df['High'], df['Low'], df['Close'], timeperiod=14)
    #pivot, s1, r1, s2, r2, _ = talib.PIVOT(df['High'], df['Low'], df['Close'], timeperiod=14)  # Example for Pivot Points
    #df['KIJUN_SEN'], df['TENKAN_SEN'], df['SENKOU_SPAN_A'], df['SENKOU_SPAN_B'], df['CHIKOU_SPAN'] = talib.ICHIMOKU(df['High'], df['Low'], df['Close'], timeperiod1=9, timeperiod2=26, timeperiod3=52)

    return df

def plot_data(df, title):
    # Create a subplot for each indicator with varying heights
    fig = make_subplots(rows=17, cols=1, shared_xaxes=True, vertical_spacing=0.02,
                        subplot_titles=('Bollinger Bands', 'ADX', 'STDDEV', 'ATR', 'CMO', 'ROC', 'Stochastic',
                                        'Williams %R', 'LR Slope', 'RSI', 'MACD', 'OBV', 'SAR', 'ULTOSC', 'MFI',
                                        'CCI', 'ICHIMOKU'),
                        row_heights=[0.2] + [0.05] * 16)

    # Plot existing indicators
    # Add traces for existing indicators ...

    # Plot Close price and Bollinger Bands with colors
    fig.add_trace(go.Scatter(x=df.index, y=df['Close'], mode='lines', name='Close', line=dict(color='blue', width=2)), row=1, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['upperband'], mode='lines', name='Upper Band', line=dict(color='green', width=1)), row=1, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['middleband'], mode='lines', name='Middle Band', line=dict(color='white', width=1)), row=1, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['lowerband'], mode='lines', name='Lower Band', line=dict(color='red', width=1)), row=1, col=1)

    # Plot other indicators in subplots with colors
    fig.add_trace(go.Scatter(x=df.index, y=df['ADX'], mode='lines', name='ADX', line=dict(color='lawngreen', width=1)), row=2, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['STDDEV'], mode='lines', name='STDDEV', line=dict(color='magenta', width=1)), row=3, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['ATR'], mode='lines', name='ATR', line=dict(color='blue', width=1)), row=4, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['CMO'], mode='lines', name='CMO', line=dict(color='red', width=1)), row=5, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['ROC'], mode='lines', name='ROC', line=dict(color='lime', width=1)), row=6, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['WILLR'], mode='lines', name='Williams %R', line=dict(color='cyan', width=1)), row=7, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['STOCH_k'], mode='lines', name='STOCH_k', line=dict(color='red', width=1)), row=8, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['STOCH_d'], mode='lines', name='STOCH_d', line=dict(color='blue', width=1)), row=8, col=1)

    # Add subplot for Linear Regression Slope
    fig.add_trace(go.Scatter(x=df.index, y=df['LR_Slope'], mode='lines', name='LR Slope', line=dict(color='yellow', width=1)), row=9, col=1)

       # Plot new indicators with bright colors
    fig.add_trace(go.Scatter(x=df.index, y=df['RSI'], mode='lines', name='RSI', line=dict(color='orange', width=1)), row=10, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['MACD'], mode='lines', name='MACD', line=dict(color='purple', width=1)), row=11, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['OBV'], mode='lines', name='OBV', line=dict(color='pink', width=1)), row=12, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['SAR'], mode='lines', name='SAR', line=dict(color='gold', width=1)), row=13, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['ULTOSC'], mode='lines', name='ULTOSC', line=dict(color='lightblue', width=1)), row=14, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['MFI'], mode='lines', name='MFI', line=dict(color='aqua', width=1)), row=15, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['CCI'], mode='lines', name='CCI', line=dict(color='violet', width=1)), row=16, col=1)
    #fig.add_trace(go.Scatter(x=df.index, y=df['KIJUN_SEN'], mode='lines', name='KIJUN_SEN', line=dict(color='yellowgreen', width=1)), row=17, col=1)

    # Customize layout and update y-axes labels
    fig.update_layout(title=title, xaxis_title='Date', yaxis_title='Price', template='plotly_dark', height=3000, showlegend=False)
    # Update y-axes labels for each subplot ...

    fig.show()

# Example usage:
#ticker = "AAPL"  # Replace with your desired ticker symbol
ticker_data = download_data(ticker, period=period)
ticker_data = calculate_indicators(ticker_data)
plot_data(ticker_data, title=f"{ticker} Stock Data with Technical Indicators")

# NEW MEGA :
import yfinance as yf
import pandas as pd
import plotly.graph_objs as go
from plotly.subplots import make_subplots
import os
from datetime import datetime
import talib

def download_data(ticker, period):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")
    return df

def calculate_indicators(df):
    # Existing indicators
    for span in [50, 100, 150, 200, 300]:
        df[f'EMA{span}'] = df['Close'].ewm(span=span, adjust=False).mean()

    upperband, middleband, lowerband = talib.BBANDS(df['Close'], timeperiod=20, nbdevup=2, nbdevdn=2, matype=0)
    df['upperband'] = upperband
    df['middleband'] = middleband
    df['lowerband'] = lowerband

    df['ADX'] = talib.ADX(df['High'], df['Low'], df['Close'], timeperiod=14)
    df['STDDEV'] = talib.STDDEV(df['Close'], timeperiod=5, nbdev=1)
    df['ATR'] = talib.ATR(df['High'], df['Low'], df['Close'], timeperiod=14)
    df['CMO'] = talib.CMO(df['Close'], timeperiod=14)
    df['ROC'] = talib.ROC(df['Close'], timeperiod=10)
    df['STOCH_k'], df['STOCH_d'] = talib.STOCH(df['High'], df['Low'], df['Close'])
    df['WILLR'] = talib.WILLR(df['High'], df['Low'], df['Close'], timeperiod=14)
    window = 14
    df['LR_Slope'] = talib.LINEARREG_SLOPE(df['Close'], timeperiod=window)

    # New indicators
    df['AD'] = talib.AD(df['High'], df['Low'], df['Close'], df['Volume'])
    df['ADOSC'] = talib.ADOSC(df['High'], df['Low'], df['Close'], df['Volume'], fastperiod=3, slowperiod=10)
    df['ADXR'] = talib.ADXR(df['High'], df['Low'], df['Close'], timeperiod=14)
    df['APO'] = talib.APO(df['Close'], fastperiod=12, slowperiod=26, matype=0)
    df['AROON_down'], df['AROON_up'] = talib.AROON(df['High'], df['Low'], timeperiod=14)
    df['AROONOSC'] = talib.AROONOSC(df['High'], df['Low'], timeperiod=14)
    df['AVGPRICE'] = talib.AVGPRICE(df['Open'], df['High'], df['Low'], df['Close'])
    df['BETA'] = talib.BETA(df['High'], df['Low'], timeperiod=5)
    df['BOP'] = talib.BOP(df['Open'], df['High'], df['Low'], df['Close'])
    df['CORREL'] = talib.CORREL(df['High'], df['Low'], timeperiod=30)
    df['DEMA'] = talib.DEMA(df['Close'], timeperiod=30)
    df['DX'] = talib.DX(df['High'], df['Low'], df['Close'], timeperiod=14)
    df['HT_DCPERIOD'] = talib.HT_DCPERIOD(df['Close'])
    df['HT_DCPHASE'] = talib.HT_DCPHASE(df['Close'])
    df['HT_PHASOR_inphase'], df['HT_PHASOR_quadrature'] = talib.HT_PHASOR(df['Close'])
    df['HT_SINE'], df['HT_LEADSINE'] = talib.HT_SINE(df['Close'])
    df['HT_TRENDLINE'] = talib.HT_TRENDLINE(df['Close'])
    df['HT_TRENDMODE'] = talib.HT_TRENDMODE(df['Close'])
    df['KAMA'] = talib.KAMA(df['Close'], timeperiod=30)
    df['LINEARREG'] = talib.LINEARREG(df['Close'], timeperiod=14)
    df['LINEARREG_ANGLE'] = talib.LINEARREG_ANGLE(df['Close'], timeperiod=14)
    df['LINEARREG_INTERCEPT'] = talib.LINEARREG_INTERCEPT(df['Close'], timeperiod=14)
    df['LINEARREG_SLOPE'] = talib.LINEARREG_SLOPE(df['Close'], timeperiod=14)
    df['MA'] = talib.MA(df['Close'], timeperiod=30, matype=0)
    df['MACDEXT'], df['MACDEXT_signal'], df['MACDEXT_hist'] = talib.MACDEXT(df['Close'], fastperiod=12, fastmatype=0, slowperiod=26, slowmatype=0, signalperiod=9, signalmatype=0)
    df['MACDFIX'], df['MACDFIX_signal'], df['MACDFIX_hist'] = talib.MACDFIX(df['Close'], signalperiod=9)
    df['MAMA'], df['FAMA'] = talib.MAMA(df['Close'], fastlimit=0.5, slowlimit=0.05)
    df['MOM'] = talib.MOM(df['Close'], timeperiod=10)
    df['NATR'] = talib.NATR(df['High'], df['Low'], df['Close'], timeperiod=14)
    df['PLUS_DI'] = talib.PLUS_DI(df['High'], df['Low'], df['Close'], timeperiod=14)
    df['PLUS_DM'] = talib.PLUS_DM(df['High'], df['Low'], timeperiod=14)
    df['PPO'] = talib.PPO(df['Close'], fastperiod=12, slowperiod=26, matype=0)
    df['ROCP'] = talib.ROCP(df['Close'], timeperiod=10)
    df['ROCR'] = talib.ROCR(df['Close'], timeperiod=10)
    df['ROCR100'] = talib.ROCR100(df['Close'], timeperiod=10)
    df['SAREXT'] = talib.SAREXT(df['High'], df['Low'], startvalue=0, offsetonreverse=0, accelerationinitlong=0.02, accelerationlong=0.02, accelerationmaxlong=0.2, accelerationinitshort=0.02, accelerationshort=0.02, accelerationmaxshort=0.2)
    df['SMA'] = talib.SMA(df['Close'], timeperiod=30)
    df['STOCHF_k'], df['STOCHF_d'] = talib.STOCHF(df['High'], df['Low'], df['Close'], fastk_period=5, fastd_period=3, fastd_matype=0)
    df['STOCHRSI_k'], df['STOCHRSI_d'] = talib.STOCHRSI(df['Close'], timeperiod=14, fastk_period=5, fastd_period=3, fastd_matype=0)
    df['T3'] = talib.T3(df['Close'], timeperiod=5, vfactor=0.7)
    df['TEMA'] = talib.TEMA(df['Close'], timeperiod=30)
    df['TRIMA'] = talib.TRIMA(df['Close'], timeperiod=30)
    df['TRIX'] = talib.TRIX(df['Close'], timeperiod=30)
    df['TSF'] = talib.TSF(df['Close'], timeperiod=14)
    df['TYPPRICE'] = talib.TYPPRICE(df['High'], df['Low'], df['Close'])
    df['VAR'] = talib.VAR(df['Close'], timeperiod=5, nbdev=1)
    df['WCLPRICE'] = talib.WCLPRICE(df['High'], df['Low'], df['Close'])
    df['WMA'] = talib.WMA(df['Close'], timeperiod=30)

    return df
def plot_data1(df, title):
    # Create a subplot for each indicator
    fig = make_subplots(rows=5, cols=1, shared_xaxes=True, vertical_spacing=0.02,
                        subplot_titles=('DX', 'HT_PHASOR_inphase', 'HT_PHASOR_quadrature', 'HT_SINE', 'LINEARREG')) # subplot_titles=('AD', 'ADOSC', 'ADXR', 'APO', 'AROON', 'AROONOSC','AVGPRICE', 'BETA', 'BOP', 'CORREL', 'DEMA', 'DX','HT_DCPERIOD', 'HT_DCPHASE', 'HT_PHASOR', 'HT_SINE','HT_TRENDLINE', 'HT_TRENDMODE', 'KAMA', 'LINEARREG'))

    fig.add_trace(go.Scatter(x=df.index, y=df['DX'], mode='lines', name='DX'), row=1, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['HT_PHASOR_inphase'], mode='lines', name='HT_PHASOR Inphase'), row=2, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['HT_PHASOR_quadrature'], mode='lines', name='HT_PHASOR Quadrature'), row=3, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['HT_SINE'], mode='lines', name='HT_SINE'), row=4, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['LINEARREG'], mode='lines', name='LINEARREG'), row=5, col=1)

    #fig.add_trace(go.Scatter(x=df.index, y=df['AD'], mode='lines', name='AD'), row=1, col=1)
    #fig.add_trace(go.Scatter(x=df.index, y=df['ADOSC'], mode='lines', name='ADOSC'), row=2, col=1)
    #fig.add_trace(go.Scatter(x=df.index, y=df['ADXR'], mode='lines', name='ADXR'), row=3, col=1)
    #fig.add_trace(go.Scatter(x=df.index, y=df['APO'], mode='lines', name='APO'), row=4, col=1)
    #fig.add_trace(go.Scatter(x=df.index, y=df['AROON_up'], mode='lines', name='AROON Up'), row=5, col=1)
    #fig.add_trace(go.Scatter(x=df.index, y=df['AROON_down'], mode='lines', name='AROON Down'), row=5, col=1)
    #fig.add_trace(go.Scatter(x=df.index, y=df['AROONOSC'], mode='lines', name='AROONOSC'), row=6, col=1)
    #fig.add_trace(go.Scatter(x=df.index, y=df['AVGPRICE'], mode='lines', name='AVGPRICE'), row=7, col=1)
    #fig.add_trace(go.Scatter(x=df.index, y=df['BETA'], mode='lines', name='BETA'), row=8, col=1)
    #fig.add_trace(go.Scatter(x=df.index, y=df['BOP'], mode='lines', name='BOP'), row=9, col=1)
    #fig.add_trace(go.Scatter(x=df.index, y=df['CORREL'], mode='lines', name='CORREL'), row=10, col=1)
    #fig.add_trace(go.Scatter(x=df.index, y=df['DEMA'], mode='lines', name='DEMA'), row=11, col=1)
    #fig.add_trace(go.Scatter(x=df.index, y=df['HT_DCPERIOD'], mode='lines', name='HT_DCPERIOD'), row=13, col=1)
    #fig.add_trace(go.Scatter(x=df.index, y=df['HT_DCPHASE'], mode='lines', name='HT_DCPHASE'), row=14, col=1)
    #fig.add_trace(go.Scatter(x=df.index, y=df['HT_LEADSINE'], mode='lines', name='HT_LEADSINE'), row=16, col=1)
    #fig.add_trace(go.Scatter(x=df.index, y=df['HT_TRENDLINE'], mode='lines', name='HT_TRENDLINE'), row=17, col=1)
    #fig.add_trace(go.Scatter(x=df.index, y=df['HT_TRENDMODE'], mode='lines', name='HT_TRENDMODE'), row=18, col=1)
    #fig.add_trace(go.Scatter(x=df.index, y=df['KAMA'], mode='lines', name='KAMA'), row=19, col=1)

    # Update layout and show figure
    #fig.update_layout(title=title, xaxis_title='Date', yaxis_title='Value', height=4000, showlegend=True)
    # Customize layout
    #fig.update_layout(title=title, xaxis_title='Date', yaxis_title='Price', template='plotly_dark', height=2000, showlegend=False)
    fig.update_layout(title=title, template='plotly_dark', height=2000, showlegend=False)

    fig.show()

def plot_data2(df, title):
    fig = make_subplots(rows=5, cols=1, shared_xaxes=True, vertical_spacing=0.02,
                        #subplot_titles=('LINEARREG_ANGLE', 'LINEARREG_INTERCEPT', 'LINEARREG_SLOPE', 'MA','MACDEXT', 'MACDFIX', 'MAMA', 'MOM', 'NATR', 'PLUS_DI','PLUS_DM', 'PPO', 'ROCP', 'ROCR', 'ROCR100', 'SAREXT','SMA', 'STOCHF', 'STOCHRSI', 'T3'))
                        subplot_titles=('LINEARREG_ANGLE', 'LINEARREG_INTERCEPT', 'LINEARREG_SLOPE','STOCHF', 'STOCHRSI'))

    fig.add_trace(go.Scatter(x=df.index, y=df['LINEARREG_ANGLE'], mode='lines', name='LINEARREG_ANGLE'), row=1, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['LINEARREG_INTERCEPT'], mode='lines', name='LINEARREG_INTERCEPT'), row=2, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['LINEARREG_SLOPE'], mode='lines', name='LINEARREG_SLOPE'), row=3, col=1)
    #fig.add_trace(go.Scatter(x=df.index, y=df['MA'], mode='lines', name='MA'), row=4, col=1)
    #fig.add_trace(go.Scatter(x=df.index, y=df['MACDEXT'], mode='lines', name='MACDEXT'), row=5, col=1)
    #fig.add_trace(go.Scatter(x=df.index, y=df['MACDFIX'], mode='lines', name='MACDFIX'), row=6, col=1)
    #fig.add_trace(go.Scatter(x=df.index, y=df['MAMA'], mode='lines', name='MAMA'), row=7, col=1)
    #fig.add_trace(go.Scatter(x=df.index, y=df['MOM'], mode='lines', name='MOM'), row=8, col=1)
    #fig.add_trace(go.Scatter(x=df.index, y=df['NATR'], mode='lines', name='NATR'), row=9, col=1)
    #fig.add_trace(go.Scatter(x=df.index, y=df['PLUS_DI'], mode='lines', name='PLUS_DI'), row=10, col=1)
    #fig.add_trace(go.Scatter(x=df.index, y=df['PLUS_DM'], mode='lines', name='PLUS_DM'), row=11, col=1)
    #fig.add_trace(go.Scatter(x=df.index, y=df['PPO'], mode='lines', name='PPO'), row=12, col=1)
    #fig.add_trace(go.Scatter(x=df.index, y=df['ROCP'], mode='lines', name='ROCP'), row=13, col=1)
    #fig.add_trace(go.Scatter(x=df.index, y=df['ROCR'], mode='lines', name='ROCR'), row=14, col=1)
    #fig.add_trace(go.Scatter(x=df.index, y=df['ROCR100'], mode='lines', name='ROCR100'), row=15, col=1)
    #fig.add_trace(go.Scatter(x=df.index, y=df['SAREXT'], mode='lines', name='SAREXT'), row=16, col=1)
    #fig.add_trace(go.Scatter(x=df.index, y=df['SMA'], mode='lines', name='SMA'), row=17, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['STOCHF_k'], mode='lines', name='STOCHF_k'), row=4, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['STOCHF_d'], mode='lines', name='STOCHF_d'), row=5, col=1)
    #fig.add_trace(go.Scatter(x=df.index, y=df['STOCHRSI_k'], mode='lines', name='STOCHRSI_k'), row=19, col=1)
    #fig.add_trace(go.Scatter(x=df.index, y=df['STOCHRSI_d'], mode='lines', name='STOCHRSI_d'), row=19, col=1)
    #fig.add_trace(go.Scatter(x=df.index, y=df['T3'], mode='lines', name='T3'), row=20, col=1)

    # Update layout and show figure
    #fig.update_layout(title=title, xaxis_title='Date', yaxis_title='Value', height=4000, showlegend=True)
    # Customize layout
    fig.update_layout(title=title, xaxis_title='Date', yaxis_title='Price', template='plotly_dark', height=2000, showlegend=False)

    fig.show()


def plot_data3(df, title):
    fig = make_subplots(rows=8, cols=1, shared_xaxes=True, vertical_spacing=0.02,
                        subplot_titles=('TSF', 'VAR', 'WCLPRICE'))
                        #subplot_titles=('TEMA', 'TRIMA', 'TRIX', 'TSF', 'TYPPRICE','VAR', 'WCLPRICE', 'WMA'))

    #fig.add_trace(go.Scatter(x=df.index, y=df['TEMA'], mode='lines', name='TEMA'), row=1, col=1)
    #fig.add_trace(go.Scatter(x=df.index, y=df['TRIMA'], mode='lines', name='TRIMA'), row=2, col=1)
    #fig.add_trace(go.Scatter(x=df.index, y=df['TRIX'], mode='lines', name='TRIX'), row=3, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['TSF'], mode='lines', name='TSF'), row=1, col=1)
    #fig.add_trace(go.Scatter(x=df.index, y=df['TYPPRICE'], mode='lines', name='TYPPRICE'), row=5, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['VAR'], mode='lines', name='VAR'), row=2, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['WCLPRICE'], mode='lines', name='WCLPRICE'), row=3, col=1)
    #fig.add_trace(go.Scatter(x=df.index, y=df['WMA'], mode='lines', name='WMA'), row=8, col=1)

    # Customize layout
    fig.update_layout(title=title, xaxis_title='Date', yaxis_title='Price', template='plotly_dark', height=2000, showlegend=False)
    # Update layout and show figure
    #fig.update_layout(title=title, xaxis_title='Date', yaxis_title='Value', height=2000, showlegend=True)
    fig.show()

def plot_dataFinal(df, title):
    fig = make_subplots(rows=9, cols=1, shared_xaxes=True, vertical_spacing=0.02,
                        subplot_titles=('TSF_and_WCLPRICE', 'VAR', 'DX', 'HT_PHASOR', 'HT_SINE', 'Linear Regression and Intercept ','LINEARREG_ANGLE', 'LINEARREG_SLOPE','STOCHF_and_STOCHRSI'))

    fig.add_trace(go.Scatter(x=df.index, y=df['TSF'], mode='lines', name='TSF'), row=1, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['VAR'], mode='lines', name='VAR'), row=2, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['WCLPRICE'], mode='lines', name='WCLPRICE'), row=1, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['DX'], mode='lines', name='DX'), row=3, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['HT_PHASOR_inphase'], mode='lines', name='Inphase'), row=4, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['HT_PHASOR_quadrature'], mode='lines', name='Quadrature'), row=4, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['HT_SINE'], mode='lines', name='HT_SINE'), row=5, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['LINEARREG'], mode='lines', name='REGRESSION'), row=6, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['LINEARREG_ANGLE'], mode='lines', name='LINEARREG_ANGLE'), row=7, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['LINEARREG_INTERCEPT'], mode='lines', name='INTERCEPT'), row=6, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['LINEARREG_SLOPE'], mode='lines', name='LINEARREG_SLOPE'), row=8, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['STOCHF_k'], mode='lines', name='STOCHF_k'), row=9, col=1)
    fig.add_trace(go.Scatter(x=df.index, y=df['STOCHF_d'], mode='lines', name='STOCHF_d'), row=9, col=1)

    # Customize layout
    #fig.update_layout(title=title, xaxis_title='Date', yaxis_title='Price', template='plotly_dark', height=2000, showlegend=False)
    fig.update_layout(title=title, template='plotly_dark', height=2000, showlegend=False)
    fig.show()

# Example usage:
#ticker = "AAPL"  # Replace with your desired ticker symbol
ticker_data = download_data(ticker, period=period)
ticker_data = calculate_indicators(ticker_data)

# Call the function with the dataframe and title
#plot_data1(ticker_data, f"{ticker} Stock Indicators")
#plot_data2(ticker_data, f"{ticker} Stock Indicators - Part 2")
#plot_data3(ticker_data, f"{ticker} Stock Indicators - Part 3")

plot_dataFinal(ticker_data, f"{ticker} Stock Indicators")

'''
# some other indicators to add
    #Relative Strength Index (RSI): Measures the speed and change of price movements.
    talib.RSI(df['Close'], timeperiod=14)

    #Moving Average Convergence Divergence (MACD): Shows the relationship between two moving averages of a securitys price.
    macd, macdsignal, macdhist = talib.MACD(df['Close'], fastperiod=12, slowperiod=26, signalperiod=9)

    #On Balance Volume (OBV): Uses volume flow to predict changes in stock price.
    talib.OBV(df['Close'], df['Volume'])

    #Parabolic SAR (SAR): Determines the direction of a markets momentum and serves as a stop-loss indicator.
    talib.SAR(df['High'], df['Low'], acceleration=0.02, maximum=0.2)

    #Ultimate Oscillator (ULTOSC): Combines short-term, intermediate, and long-term price action into one oscillator.
    talib.ULTOSC(df['High'], df['Low'], df['Close'], timeperiod1=7, timeperiod2=14, timeperiod3=28)

    #Money Flow Index (MFI): Identifies overbought or oversold conditions in an asset.
    talib.MFI(df['High'], df['Low'], df['Close'], df['Volume'], timeperiod=14)

    #Commodity Channel Index (CCI): Determines a new trend or warns of extreme conditions.
    talib.CCI(df['High'], df['Low'], df['Close'], timeperiod=14)

    #Pivot Points, Support and Resistance (PP, S1, R1, etc.): Levels used to identify the direction of movement and potential support/resistance levels.
    pivot, s1, r1, s2, r2, etc. = talib.PIVOT(df['High'], df['Low'], df['Close'], timeperiod=14)

    #Ichimoku Kinko Hyo (ICHIMOKU): Defines support and resistance levels, identifies trend direction, gauges momentum, and provides trading signals.
    kijun_sen, tenkan_sen, senkou_span_a, senkou_span_b, chikou_span = talib.ICHIMOKU(df['High'], df['Low'], df['Close'], timeperiod1=9, timeperiod2=26, timeperiod3=52)
'''



#@title UP/DONE Consecutive Days and Daily % moves
import yfinance as yf
import pandas as pd
import plotly.graph_objs as go
from plotly.subplots import make_subplots
from datetime import datetime
import os
import numpy as np

def download_data(ticker, period):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")
    return df

def calculate_consecutive_trends(df):
    df['Trend'] = np.sign(df['Close'].diff())
    df['Consecutive'] = df['Trend'].groupby((df['Trend'] != df['Trend'].shift()).cumsum()).cumcount() + 1
    df['Consecutive'] *= df['Trend']
    df['Pct_Change'] = df['Close'].pct_change() * 100
    return df

def plot_data_with_subplots(df, title):
    # Define row heights where the first two rows are half the size of the last two
    row_heights = [.1, .5, 1, 1]

    # Create subplots with 4 rows and custom row heights
    fig = make_subplots(rows=4, cols=1, shared_xaxes=True, vertical_spacing=0.02,
                        subplot_titles=(title, 'Market Data', 'Consecutive Days Up/Down', 'Daily Percentage Change'),
                        row_heights=row_heights)

    # Candlestick plot
    fig.add_trace(go.Candlestick(x=df.index, open=df['Open'], high=df['High'], low=df['Low'], close=df['Close'], name='Market Data'), row=1, col=1)

    # Consecutive trends subplot (new subplot)
    positive_consecutive = df['Consecutive'].apply(lambda x: x if x > 0 else 0)
    negative_consecutive = df['Consecutive'].apply(lambda x: x if x < 0 else 0)
    fig.add_trace(go.Bar(x=df.index, y=positive_consecutive, marker_color='green', name='Consecutive Up'), row=3, col=1)
    fig.add_trace(go.Bar(x=df.index, y=negative_consecutive, marker_color='red', name='Consecutive Down'), row=3, col=1)

    # Percentage change subplot
    fig.add_trace(go.Bar(x=df.index, y=df['Pct_Change'], marker_color=df['Pct_Change'].apply(lambda x: 'blue' if x > 0 else 'orange'), name='Percentage Change'), row=4, col=1)

    # Update layout
    # Adjust the height to accommodate the custom row heights
    fig.update_layout(height=1800, showlegend=False)

    # Show the figure
    fig.show()


def plot_data_with_subplotsOLD(df, title):
    # Create subplots with 4 rows
    fig = make_subplots(rows=4, cols=1, shared_xaxes=True, vertical_spacing=0.02, subplot_titles=(title, 'Market Data', 'Consecutive Days Up/Down ', 'Daily Percentage Change'))

    # Candlestick plot
    fig.add_trace(go.Candlestick(x=df.index, open=df['Open'], high=df['High'], low=df['Low'], close=df['Close'], name='Market Data'), row=1, col=1)

    # Consecutive trends subplot (new subplot)
    # We separate positive and negative consecutive trends for correct plotting
    positive_consecutive = df['Consecutive'].apply(lambda x: x if x > 0 else 0)
    negative_consecutive = df['Consecutive'].apply(lambda x: x if x < 0 else 0)
    fig.add_trace(go.Bar(x=df.index, y=positive_consecutive, marker_color='green', name='Consecutive Up'), row=3, col=1)
    fig.add_trace(go.Bar(x=df.index, y=negative_consecutive, marker_color='red', name='Consecutive Down'), row=3, col=1)

    # Percentage change subplot
    fig.add_trace(go.Bar(x=df.index, y=df['Pct_Change'], marker_color=df['Pct_Change'].apply(lambda x: 'blue' if x > 0 else 'orange'), name='Percentage Change'), row=4, col=1)

    # Update layout
    fig.update_layout(height=1600, showlegend=False)

    # Show the figure
    fig.show()





# Example usage:
#ticker = "AAPL"  # Replace with desired ticker
ticker_data = download_data(ticker, period=period)
ticker_data = calculate_consecutive_trends(ticker_data)

# Plot data with subplots
plot_data_with_subplots(ticker_data, title=f"{ticker} Stock ")

#@title  NEW 7 of 8, or 6 of 7 etc last sequence of days minus one : not working  yet... just a prototype
import yfinance as yf
import pandas as pd
import plotly.graph_objs as go
from plotly.subplots import make_subplots
from datetime import datetime
import os
import numpy as np

def download_data(ticker, period):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")
    return df

def calculate_trend_counts(df, window_sizes):
    df['Trend'] = np.sign(df['Close'].diff())

    for window_size in window_sizes:
        window_trends = df['Trend'].rolling(window=window_size).sum()
        df[f'Trend_Count_{window_size}'] = window_trends

    df['Pct_Change'] = df['Close'].pct_change() * 100
    return df

def plot_data_with_subplots(df, title, window_sizes):
    num_subplots = len(window_sizes) + 3
    row_heights = [.1] + [1] * (num_subplots - 1)

    subplot_titles = [title, 'Market Data'] + [f'Trend Count (Last {window_size} Days)' for window_size in window_sizes] + ['Daily Percentage Change']

    fig = make_subplots(rows=num_subplots, cols=1, shared_xaxes=True, vertical_spacing=0.02,
                        subplot_titles=subplot_titles, row_heights=row_heights)

    fig.add_trace(go.Candlestick(x=df.index, open=df['Open'], high=df['High'], low=df['Low'], close=df['Close'], name='Market Data'), row=1, col=1)

    for i, window_size in enumerate(window_sizes, start=2):
        fig.add_trace(go.Bar(x=df.index, y=df[f'Trend_Count_{window_size}'], marker_color='blue', name=f'Trend Count (Last {window_size} Days)'), row=i+1, col=1)

    fig.add_trace(go.Bar(x=df.index, y=df['Pct_Change'], marker_color=df['Pct_Change'].apply(lambda x: 'blue' if x > 0 else 'orange'), name='Percentage Change'), row=num_subplots, col=1)

    fig.update_layout(height=1800, showlegend=False)
    fig.show()

# Example usage:
#ticker = "AAPL"  # Replace with desired ticker
#period = "1y"  # Replace with desired period
window_sizes = [4, 5, 7]  # Adjust the window sizes as needed

ticker_data = download_data(ticker, period)
ticker_data = calculate_trend_counts(ticker_data, window_sizes)

plot_data_with_subplots(ticker_data, title=f"{ticker} Stock", window_sizes=window_sizes)

#@title consecutive days up / down
import yfinance as yf
import pandas as pd
import plotly.graph_objs as go
from plotly.subplots import make_subplots
from datetime import datetime
import os
import numpy as np
import scipy.stats as stats

def download_data(ticker, period):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")
    return df

def calculate_consecutive_trends(df):
    df['Trend'] = np.sign(df['Close'].diff())
    df['Consecutive'] = df['Trend'].groupby((df['Trend'] != df['Trend'].shift()).cumsum()).cumcount() + 1
    df['Consecutive'] *= df['Trend']
    df['Pct_Change'] = df['Close'].pct_change() * 100
    return df

def plot_histograms_and_gaussian(df, title):
    # Separate the data into positive and negative consecutive days
    positive_consecutive = df['Consecutive'][df['Consecutive'] > 0]
    negative_consecutive = df['Consecutive'][df['Consecutive'] < 0]

    # Create subplots: 1 row, 2 columns
    fig = make_subplots(rows=1, cols=2, subplot_titles=('Consecutive Days Up', 'Consecutive Days Down'))

    # Histogram for positive consecutive days
    fig.add_trace(go.Histogram(x=positive_consecutive, name='Consecutive Up'), row=1, col=2)

    # Histogram for negative consecutive days
    fig.add_trace(go.Histogram(x=negative_consecutive, name='Consecutive Down'), row=1, col=1)


    # Gaussian Distribution for negative consecutive days
    if len(negative_consecutive) > 0:
        mean_neg = np.mean(negative_consecutive)
        std_dev_neg = np.std(negative_consecutive)
        x_neg = np.linspace(min(negative_consecutive), max(negative_consecutive), 100)
        gaussian_distribution_neg = stats.norm.pdf(x_neg, mean_neg, std_dev_neg)
        #fig.add_trace(go.Scatter(x=x_neg, y=gaussian_distribution_neg, mode='lines', name='Gaussian Down'), row=1, col=2)

    # Gaussian Distribution for positive consecutive days
    if len(positive_consecutive) > 0:
        mean_pos = np.mean(positive_consecutive)
        std_dev_pos = np.std(positive_consecutive)
        x_pos = np.linspace(min(positive_consecutive), max(positive_consecutive), 100)
        gaussian_distribution_pos = stats.norm.pdf(x_pos, mean_pos, std_dev_pos)
        #fig.add_trace(go.Scatter(x=x_pos, y=gaussian_distribution_pos, mode='lines', name='Gaussian Up'), row=1, col=1)


    # Update layout
    fig.update_layout(title=f'Consecutive Days and Gaussian Distribution for {title}', barmode='overlay')

    # Show the figure
    fig.show()

# Example usage
#ticker = "AAPL"  # Replace with desired ticker
ticker_data = download_data(ticker, period=period)
ticker_data = calculate_consecutive_trends(ticker_data)

# Plot histograms and Gaussian distributions
plot_histograms_and_gaussian(ticker_data, title=f"{ticker} Stock")



#@title candle stick patterns :
import yfinance as yf
import pandas as pd
import plotly.graph_objs as go
import talib
from datetime import datetime
import os

def download_data(ticker, period):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")
    return df

def add_selected_candlestick_patterns(df):
    # Selected patterns
    selected_patterns = ['CDLHAMMER', 'CDLINVERTEDHAMMER', 'CDLENGULFING',
                         'CDLPIERCING', 'CDLDARKCLOUDCOVER', 'CDLDOJI',
                         'CDLMORNINGSTAR', 'CDLEVENINGSTAR', 'CDLSHOOTINGSTAR',
                         'CDLHARAMI']

    for pattern in selected_patterns:
        pattern_function = getattr(talib, pattern)
        df[pattern] = pattern_function(df['Open'], df['High'], df['Low'], df['Close'])

    return df

def plot_data(df, title):
    fig = go.Figure()

    fig.add_trace(go.Candlestick(x=df.index, open=df['Open'], high=df['High'], low=df['Low'], close=df['Close'], name='Market Data'))

    # Highlight the selected patterns on the chart
    for pattern in ['CDLHAMMER', 'CDLINVERTEDHAMMER', 'CDLENGULFING',
                    'CDLPIERCING', 'CDLDARKCLOUDCOVER', 'CDLDOJI',
                    'CDLMORNINGSTAR', 'CDLEVENINGSTAR', 'CDLSHOOTINGSTAR',
                    'CDLHARAMI']:
        fig.add_trace(go.Scatter(
            x=df.index,
            y=df[pattern],
            mode='markers',
            name=pattern[3:]
        ))

    fig.update_layout(title=title, xaxis_title='Date', yaxis_title='Price', height=800, width=1200)
    fig.show()

# Example usage:
#ticker = "NKE"  # Replace with desired ticker
ticker_data = download_data(ticker, period=period)
ticker_data = add_selected_candlestick_patterns(ticker_data)

# Plot data with technical indicators
plot_data(ticker_data, title=f"{ticker} Stock Analysis")

#explanations:
'''
CDLHAMMER: A bullish reversal pattern. Its shape resembles a hammer with a small real body at the top of a downtrend and a long lower shadow.
CDLINVERTEDHAMMER: Similar to a hammer but inverted. It also suggests a potential bullish reversal but is considered less reliable than the hammer.
CDLENGULFING: A two-candle pattern.

    Bullish Engulfing: A large green (bullish) candle fully engulfs a smaller red (bearish) preceding candle. Indicates buying pressure overcoming selling pressure.
    Bearish Engulfing: The opposite; a large red candle engulfs a smaller green candle, suggesting a downtrend may be starting.

CDLPIERCING: A bullish reversal pattern involving a long red candle followed by a long green candle that closes above the midpoint of the previous red body.
CDLDARKCLOUDCOVER: The bearish counterpart of the piercing pattern. A long green candle is then followed by a red candle that opens higher but closes below the midpoint of the preceding green body.
CDLDOJI: A candle where the open and close are virtually the same. Dojis represent indecision or a balance between buyers and sellers.
CDLMORNINGSTAR: A three-candle bullish reversal pattern, consisting of a red candle, a small-bodied candle (often a doji), and then a green candle.
CDLEVENINGSTAR: The bearish counterpart of the morning star, with a green candle followed by a small-bodied candle and then a red candle.
CDLSHOOTINGSTAR: Similar to an inverted hammer but occurring during an uptrend, the shooting star has a long upper shadow and a small real body near the low, potentially signaling a bearish reversal.
CDLHARAMI: A two-candle pattern suggesting a potential reversal or pause in the trend. It consists of a long-bodied candle followed by a smaller candle that is contained within the body of the first one.
'''

#@title OPTIONS GRAPHS
import yfinance as yf
import pandas as pd
import plotly.express as px
import os
from datetime import datetime, timedelta

# Set the ticker and desired date for options data
#ticker = 'AAPL'  # Replace 'AAPL' with your stock's ticker
myWeeks=4
target_date = datetime.today() + timedelta(weeks=myWeeks)

def download_options_data(ticker, date):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/options.{date}.{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        print(f"Options data for {ticker} found on disk.")
    except FileNotFoundError:
        # Download options data
        stock = yf.Ticker(ticker)
        options = stock.option_chain(date)
        df = pd.concat([options.calls, options.puts])
        df.to_csv(data_file)
        print(f"Options data for {ticker} downloaded and saved to disk.")
    return df

# Find the nearest options date and get current stock price
stock = yf.Ticker(ticker)
options_dates = stock.options
nearest_date = min(options_dates, key=lambda d: abs(datetime.strptime(d, "%Y-%m-%d") - target_date))
current_price = stock.history(period=period)['Close'].iloc[-1]

# Download data
options_data = download_options_data(ticker, nearest_date)

# Split the data into calls and puts
calls_data = options_data[options_data['contractSymbol'].str.contains('C')]
puts_data = options_data[options_data['contractSymbol'].str.contains('P')]

# Replace NaN values in 'volume' with a default size for both calls and puts
default_size_calls = calls_data['volume'].dropna().min()
default_size_puts = puts_data['volume'].dropna().min()
calls_data['volume'].fillna(default_size_calls, inplace=True)
puts_data['volume'].fillna(default_size_puts, inplace=True)

# Custom function to create scatter plot
# Custom function to create scatter plot
def create_plot(data, color_scale, title):
    fig = px.scatter(data, x="strike", y="openInterest",
                     size="openInterest", color="openInterest",
                     opacity=0.8, color_continuous_scale=color_scale)

    fig.update_layout(title=f"{ticker} {title} (Strike vs. Open Interest) - Current Price: ${current_price:.2f}",
                      xaxis_title="Strike Price", yaxis_title="Open Interest",
                      xaxis_showgrid=False, yaxis_showgrid=False,
                      plot_bgcolor='black', paper_bgcolor='black',
                      font_color='white')
    return fig

def create_plotOrig(data, color_scale, title):
    fig = px.scatter(data, x="strike", y="openInterest",
                     size="volume", color="volume",
                     opacity=0.8, color_continuous_scale=color_scale)

    fig.update_layout(title=f"{ticker} {title} (Strike vs. Open Interest) - Current Price: ${current_price:.2f}",
                      xaxis_title="Strike Price", yaxis_title="Open Interest",
                      xaxis_showgrid=False, yaxis_showgrid=False,
                      plot_bgcolor='black', paper_bgcolor='black',
                      font_color='white')
    return fig

# Plotting Calls
fig_calls = create_plot(calls_data, "Blues", "Call Options")
fig_calls.show()

# Plotting Puts
fig_puts = create_plot(puts_data, "Reds", "Put Options")
fig_puts.show()















"""The put/call ratio is a popular sentiment indicator that gauges the overall mood of the market towards a stock. Here's how to interpret the put/call ratio chart based on the image you provided:

Ratio Values:

A put/call ratio greater than 1 indicates that there are more puts than calls, suggesting that investors are potentially expecting the stock's price to decline.
A put/call ratio less than 1 means there are more calls than puts, suggesting a bullish outlook where investors expect the price to rise.
Specific Strikes:

High ratios at specific strike prices may point to areas where investors feel particularly strong about potential downward movement in the stock's price.
Conversely, lower ratios may highlight confidence in potential upward movement, especially if the strikes are above the current stock price.
High Ratios:

Extremely high ratios, as seen in your chart at certain strike prices, could suggest that investors are either heavily hedging their positions expecting a downturn or speculating on a decrease in the stock's price.
Be cautious with outlier values; they could be influenced by large individual trades and may not reflect broader market sentiment.
Strike Prices Near Current Stock Price:

The put/call ratio at strike prices close to the current stock price can be particularly telling. If these ratios are high, it indicates a bearish sentiment near the current market price. If they are low, it indicates bullish sentiment.
Overall Interpretation:

The general level of the put/call ratio across all strikes can give you an overall sentiment indication. If most of the ratios across strikes are above 1, it could be interpreted as bearish. If they are below 1, it could be bullish.
It's also important to compare the put/call ratio with historical averages for the ticker. A ratio that's high relative to historical norms can indicate more bearish sentiment than usual, and vice versa.
Market Context:

The put/call ratio should not be used in isolation. Market context, news, upcoming events (like earnings reports), and technical analysis should all be considered when interpreting this ratio.
Trading Volume:

Ensure that the analysis accounts for the volume of trades. A high ratio on low volume may not be as significant as a slightly lower ratio on high volume.
In the chart you've shared, you'd look for clusters of high or low ratios and their respective strike prices to analyze sentiment. If high ratios cluster above the current price and low ratios below it, this could indicate a bearish skew in expectations. If it's the opposite, with low ratios above and high ratios below, it could suggest bullish sentiment.
"""

#@title Compare stock's relative performance by its sector
import yfinance as yf
import pandas as pd
import plotly.graph_objs as go
from scipy.stats import linregress
from datetime import datetime
import os

def download_data(ticker, period):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}.csv"
    sector_file = f"{data_dir}/{ticker}_sector.csv"

    # Fetching the stock data
    try:
        df = pd.read_csv(data_file)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")

    # Fetching the sector information
    stock = yf.Ticker(ticker)
    sector = stock.info.get("sector", "Unknown")
    with open(sector_file, 'w') as file:
        file.write(f"{ticker},{sector}")
        print(f"Sector information for {ticker} saved to disk.")

    return df, sector

def add_linear_regression_bands(df):
    df_numeric_index = pd.to_numeric(df.index)
    slope, intercept, _, _, _ = linregress(df_numeric_index, df['Close'])
    df['Linear_Reg'] = intercept + slope * df_numeric_index
    df['Residuals'] = df['Close'] - df['Linear_Reg']
    residuals_std = df['Residuals'].std()

    desired_values = [.5, 1, 1.25, 1.5, 1.75, 2, 2.25, 3, 4]

    for i, num_std in enumerate(desired_values):
        df[f'Reg_High_{i+1}std'] = df['Linear_Reg'] + residuals_std * num_std
        df[f'Reg_Low_{i+1}std'] = df['Linear_Reg'] - residuals_std * num_std

    return df

def plot_data(df, title):
    fig = go.Figure()

    # Define desired_values within the plot_data function
    desired_values = [.5, 1, 1.25, 1.5, 1.75, 2, 2.25, 3, 4]

    fig.add_trace(go.Candlestick(x=df.index, open=df['Open'], high=df['High'], low=df['Low'], close=df['Close'], name='Market Data'))
    fig.add_trace(go.Scatter(x=df.index, y=df['Linear_Reg'], line=dict(color='blue', width=2), name='Linear Regression'))

    colors = ['grey', 'green', 'orange', 'red', 'purple', 'brown', 'pink', 'gray', 'blue']  # Add more colors as needed
    for i, num_std in enumerate(desired_values):
        fig.add_trace(go.Scatter(
            x=df.index,
            y=df[f'Reg_High_{i+1}std'],
            line=dict(color=colors[i], width=1, dash='dot'),
            name=f'Reg High {num_std} std'
        ))
        fig.add_trace(go.Scatter(
            x=df.index,
            y=df[f'Reg_Low_{i+1}std'],
            line=dict(color=colors[i], width=1, dash='dot'),
            name=f'Reg Low {num_std} std'
        ))

    fig.update_layout(title=title, xaxis_title='Date', yaxis_title='Price', height=800, width=1200)
    fig.show()


def plot_dataOrig(df, title):
    fig = go.Figure()

    fig.add_trace(go.Candlestick(x=df.index, open=df['Open'], high=df['High'], low=df['Low'], close=df['Close'], name='Market Data'))

    fig.add_trace(go.Scatter(x=df.index, y=df['Linear_Reg'], line=dict(color='blue', width=2), name='Linear Regression'))
    colors = ['grey', 'green', 'orange', 'red', 'purple', 'brown', 'pink', 'gray', 'blue']  # Add more colors as needed
    for i, num_std in enumerate(desired_values):
        fig.add_trace(go.Scatter(
            x=df.index,
            y=df[f'Reg_High_{i+1}std'],
            line=dict(color=colors[i], width=1, dash='dot'),
            name=f'Reg High {num_std} std'
        ))
        fig.add_trace(go.Scatter(
            x=df.index,
            y=df[f'Reg_Low_{i+1}std'],
            line=dict(color=colors[i], width=1, dash='dot'),
            name=f'Reg Low {num_std} std'
        ))

    fig.update_layout(title=title, xaxis_title='Date', yaxis_title='Price', height=800, width=1200)
    fig.show()

# Example usage:
ticker = "SPY"  # Replace with desired ticker
ticker_data, sector = download_data(ticker, period=period)
ticker_data = add_linear_regression_bands(ticker_data)

# Plot data with technical indicators
plot_data(ticker_data, title=f"{ticker} Stock Analysis - Sector: {sector}")

#@title JUST CANDLESTICKS
import yfinance as yf
import pandas as pd
import plotly.graph_objs as go
from scipy.signal import argrelextrema
from datetime import datetime
import os
import numpy as np

def download_data(ticker, period):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")
    return df

def find_support_resistance(df, window=100):
    # Find local maxima for resistance
    df['resistance'] = df['High'][argrelextrema(df['High'].values, np.greater_equal, order=window)[0]]

    # Find local minima for support
    df['support'] = df['Low'][argrelextrema(df['Low'].values, np.less_equal, order=window)[0]]

    return df

def plot_data(df, title):
    fig = go.Figure()

    fig.add_trace(go.Candlestick(x=df.index, open=df['Open'], high=df['High'], low=df['Low'], close=df['Close'], name='Market Data'))

    # Plot support and resistance
    fig.add_trace(go.Scatter(x=df.index, y=df['support'], line=dict(color='green', width=1), name='Support'))
    fig.add_trace(go.Scatter(x=df.index, y=df['resistance'], line=dict(color='red', width=1), name='Resistance'))

    fig.update_layout(title=title, xaxis_title='Date', yaxis_title='Price', height=800, width=1200)
    fig.show()

# Example usage:
#ticker = "NKE"  # Replace with desired ticker
ticker_data = download_data(ticker, period=period)
ticker_data = find_support_resistance(ticker_data)

# Plot data with support and resistance
plot_data(ticker_data, title=f"{ticker} Stock Analysis")

#@title 50,100,150,200,300 Original View
import yfinance as yf
import pandas as pd
import matplotlib.pyplot as plt
import os
from datetime import datetime

def download_data(ticker, period):
    """Downloads data from yfinance for the specified ticker and period,
       saving it to a local directory structure.
    """
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)  # Create directories if needed, including the root DATA directory

    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")

    return df

def calculate_emas(df, spans):
    """Calculates Exponential Moving Averages (EMAs) for the given DataFrame and spans."""
    for span in spans:
        df[f"EMA{span}"] = df["Close"].ewm(span=span, min_periods=span).mean()
    return df

def plot_data(df, columns, highlight_data=None, title=""):
    """Plots the specified columns from the DataFrame, with optional highlights."""
    plt.figure(figsize=(12, 6))

    # Plot the entire dataset
    df[columns].plot(label=columns, style=["b-", "-", "-", "-", "-"])

    # Process and plot the highlights
    if highlight_data:
        # Data for the last 200 and 30 periods
        last_200_periods = df.iloc[-200:]
        last_30_periods = df.iloc[-30:]

        for h_type, data, color, label in highlight_data:
            if h_type == "max":
                # Max in last 200 periods
                max_point_200 = last_200_periods[data.name].idxmax()
                plt.scatter(max_point_200, last_200_periods.loc[max_point_200, data.name], c=color, s=200, label=label + " (200)")

                # Max in last 30 periods
                max_point_30 = last_30_periods[data.name].idxmax()
                plt.scatter(max_point_30, last_30_periods.loc[max_point_30, data.name], c=color, s=100, label=label + " (30)")

            elif h_type == "min":
                # Min in last 200 periods
                min_point_200 = last_200_periods[data.name].idxmin()
                plt.scatter(min_point_200, last_200_periods.loc[min_point_200, data.name], c=color, s=200, label=label + " (200)")

                # Min in last 30 periods
                min_point_30 = last_30_periods[data.name].idxmin()
                plt.scatter(min_point_30, last_30_periods.loc[min_point_30, data.name], c=color, s=100, label=label + " (30)")

    # Customize styling and display
    plt.title(title)
    plt.xlabel("Period")  # Adjust label as needed
    plt.ylabel("Price")
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    plt.show()



def plot_dataSecond(df, columns, highlight_data=None, title=""):
    """Plots the specified columns from the DataFrame, with optional highlights."""
    plt.figure(figsize=(12, 6))

    # Plot the entire dataset
    df[columns].plot(label=columns, style=["b-", "-", "-", "-", "-"])

    # Process and plot the highlights for the last 200 periods
    if highlight_data:
        last_200_periods = df.iloc[-200:]  # Data for the last 200 periods

        for h_type, data, color, label in highlight_data:
            if h_type == "max":
                max_point = last_200_periods[data.name].idxmax()  # Get index of max value in the last 200 periods
                plt.scatter(max_point, last_200_periods.loc[max_point, data.name], c=color, s=200, label=label)
            elif h_type == "min":
                min_point = last_200_periods[data.name].idxmin()  # Get index of min value in the last 200 periods
                plt.scatter(min_point, last_200_periods.loc[min_point, data.name], c=color, s=200, label=label)

    # Customize styling and display
    plt.title(title)
    plt.xlabel("Period")  # Adjust label as needed
    plt.ylabel("Price")
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    plt.show()



def plot_dataOrig(df, columns, highlight_data=None, title=""):
    """Plots the specified columns from the DataFrame, with optional highlights."""
    plt.figure(figsize=(12, 6))

    # Filter for the last 200 periods directly based on the numeric index
    last_200_periods = df.iloc[-200:]

    # Plot the filtered data
    last_200_periods[columns].plot(label=columns, style=["b-", "-", "-", "-", "-"])

    # Add optional highlights (if applicable)
    if highlight_data:
        filtered_highlight_data = []  # Create a list to store filtered highlight data
        for h_type, data, color, label in highlight_data:
            filtered_data = data.iloc[-200:]  # Filter highlight data to match the last 200 periods
            filtered_highlight_data.append((h_type, filtered_data, color, label))

        for h_type, data, color, label in filtered_highlight_data:
            if h_type == "max":
                plt.scatter(last_200_periods.index[data == data.max()], data.max(), c=color, s=200, label=label)
            elif h_type == "min":
                plt.scatter(last_200_periods.index[data == data.min()], data.min(), c=color, s=200, label=label)

    # Customize styling and display
    plt.title(title)
    plt.xlabel("Period")  # Adjust label as needed
    plt.ylabel("Price")
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    plt.show()

# Example usage:
#ticker = "fdx"  # Replace "NKE" with your desired ticker symbol
ticker_data = download_data(ticker, period=period)
ticker_data = calculate_emas(ticker_data, spans=[50, 100, 150, 200, 300])

# Define highlight data (adjust as needed)
highlight_data = [
    ("max", ticker_data["Close"], "green", f"Highest Close (Last 200 Periods) for {ticker}"),  # Adjust label as needed
    ("min", ticker_data["Close"], "red", f"Lowest Close (Last 200 Periods) for {ticker}"),  # Adjust label as needed
]

# Plot data with highlights for the last 200 periods
plot_data(ticker_data, columns=["Close", "EMA50", "EMA100", "EMA150", "EMA200", "EMA300"], highlight_data=highlight_data, title=f"{ticker} Closing Price and EMAs (Last 200 Periods) with Highlights")  # Adjust title as needed

"""Explanations:
When examining the behavior of moving averages, professionals often use specific terminology to describe their movement and patterns. Here's how they typically refer to the scenarios you've described:

(Spread Out EMAs): When the exponential moving averages (EMAs) are spread out from each other, it typically indicates a period of trending market or directional movement. This spread can suggest a strong move in the price, either upwards or downwards, depending on the direction of the EMAs. When EMAs separate widely, it's often referred to as divergence or fanning out in trading parlance. This can be a signal that the trend is strong and may continue.

(Bunched Up EMAs): Conversely, when EMAs come close together or converge, it often signifies a consolidation period or a low-volatility environment in the market. This bunched-up scenario is typically referred to as a convergence of moving averages or a compression. It might indicate indecision among traders or a balance between buyers and sellers. Compressions can sometimes precede a breakout or breakdown, as the market may be coiling before a significant move.

Understanding these patterns can be valuable for traders, as they may offer insights into market momentum and potential reversals. However, it's important to consider them in the context of other indicators and market conditions.

There are several indicators within TA-Lib that can help you analyze market conditions like the convergence and divergence of moving averages. Here are a few that might be useful:

ADX (Average Directional Movement Index): This indicator can help determine the strength of a trend. A rising ADX indicates a strong trend, while a falling ADX suggests a weakening trend or a period of consolidation.

Bollinger Bands (BBANDS): Bollinger Bands can be useful for identifying periods of low volatility when the bands contract and potential breakouts when the bands start to expand.

Standard Deviation (STDDEV): This can measure the spread of prices around the mean price, which can help in identifying periods of volatility compression and expansion.

ATR (Average True Range): The ATR is a volatility indicator that measures the degree of price volatility. Low ATR values can indicate a compression in price movement (similar to the EMAs bunching up), and higher values can indicate expansion.

CMO (Chande Momentum Oscillator): This oscillator can help identify the momentum of the market. During periods of compression where the EMAs bunch up, the CMO may hover near zero, indicating a lack of strong momentum.

ROC (Rate of change): This indicator measures the percentage change in price from one period to the next, which can help identify periods of increasing or decreasing momentum associated with diverging or converging EMAs.

Stochastic Oscillator (STOCH): Although you've excluded it from consideration, it's worth noting that the stochastic can be used to identify overbought and oversold conditions, which can occur at the extremes of EMA compression or divergence.

Williams %R (WILLR): Similar to the Stochastic Oscillator, this indicator can also identify overbought and oversold conditions which can sometimes correspond with the converging and diverging of EMAs.

By combining these indicators with the analysis of EMA patterns, you can gain a more comprehensive view of the market's behavior, allowing you to make more informed trading decisions.





"""

#@title MEGA candlesticks ( everything )
import yfinance as yf
import pandas as pd
import plotly.graph_objs as go
import talib
from datetime import datetime
import os

def download_data(ticker, period):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")
    return df

def add_all_candlestick_patterns(df):
    # Add all TA-Lib candlestick patterns
    pattern_names = talib.get_function_groups()['Pattern Recognition']

    for pattern in pattern_names:
        pattern_function = getattr(talib, pattern)
        df[pattern] = pattern_function(df['Open'], df['High'], df['Low'], df['Close'])

    return df

def plot_data(df, title):
    fig = go.Figure()

    fig.add_trace(go.Candlestick(x=df.index, open=df['Open'], high=df['High'], low=df['Low'], close=df['Close'], name='Market Data'))

    # Add each pattern to the chart
    for pattern in talib.get_function_groups()['Pattern Recognition']:
        fig.add_trace(go.Scatter(
            x=df.index,
            y=df[pattern],
            mode='markers',
            name=pattern
        ))

    fig.update_layout(title=title, xaxis_title='Date', yaxis_title='Price', height=800, width=1200)
    fig.show()

# Example usage:
#ticker = "NKE"  # Replace with desired ticker
ticker_data = download_data(ticker, period=period)
ticker_data = add_all_candlestick_patterns(ticker_data)

# Plot data with technical indicators
plot_data(ticker_data, title=f"{ticker} Stock Analysis")

'''
import sys
print('exiting anything under here needs debugging first ')
sys.exit('exiting!')
'''

#@title Trend Line Analysis
import os
import yfinance as yf
import pandas as pd
import plotly.graph_objs as go
from datetime import datetime
from sympy import symbols, Eq, solve

# Function to download data and save to CSV

def download_dataOrig(ticker, period):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")
    return df



def download_data(ticker, period):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"data/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        df['Date'] = pd.to_datetime(df['Date'])  # Ensure 'Date' column is of datetime type
        df.set_index('Date', inplace=True)  # Set 'Date' as the index
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")
    return df

# Function to calculate the intersection date of trend lines
def calculate_intersection_date(highest_peak_last_six_months_date, highest_peak_last_six_months_value,
                                lowest_point_current_month_date, lowest_point_current_month_value):
    # Convert dates to ordinal numbers
    x1 = highest_peak_last_six_months_date.toordinal()
    x2 = lowest_point_current_month_date.toordinal()
    y1 = highest_peak_last_six_months_value
    y2 = lowest_point_current_month_value

    # Calculate slope and y-intercept for the trend line
    m_trend = (y2 - y1) / (x2 - x1)
    b_trend = y1 - m_trend * x1

    # Solve for the date at which the two lines are equal
    x = symbols('x')
    equation = Eq(m_trend * x + b_trend, m_trend * x + b_trend)
    intersection_x = solve(equation, x)

    # Convert the ordinal number back to a date
    if intersection_x:
        intersection_date = datetime.fromordinal(int(intersection_x[0]))
        return intersection_date
    else:
        return None

# Function to plot the data as candlestick charts using Plotly
def plot_data_as_candlesticks(df, ticker):
    # Create candlestick trace
    trace = go.Candlestick(
        x=df.index,
        open=df['Open'],
        high=df['High'],
        low=df['Low'],
        close=df['Close'],
        name='Candlesticks'
    )

    # Set up the Plotly figure
    fig = go.Figure(trace)

    # Find the highest peak in the last six months and add a trend line
    highest_peak_last_six_months_date = df.last('6M')['Close'].idxmax()
    highest_peak_last_six_months_value = df.last('6M')['Close'].max()

    fig.add_trace(go.Scatter(x=[highest_peak_last_six_months_date, df.index[-1]],
                             y=[highest_peak_last_six_months_value, df['Close'][-1]],
                             mode='lines', line=dict(color='red'), name='Trend Line - Peaks'))

    # Find the lowest trough in the current month and add a trend line
    lowest_point_current_month_date = df['Close'].idxmin()
    lowest_point_current_month_value = df['Close'].min()

    fig.add_trace(go.Scatter(x=[lowest_point_current_month_date, df.index[-1]],
                             y=[lowest_point_current_month_value, df['Close'][-1]],
                             mode='lines', line=dict(color='green'), name='Trend Line - Troughs'))

    # Add layout and show figure
    fig.update_layout(title=f"{ticker} Trend Line Analysis ", xaxis_title='Date', yaxis_title='Price')
    fig.show()

# Main function to run the analysis
def main():
    #ticker = "NVDA"  # Replace with desired ticker
    #period = "1y"
    df = download_data(ticker, period=period)
    plot_data_as_candlesticks(df, ticker)

if __name__ == '__main__':
    main()

#@title Support levels
import os
import yfinance as yf
import pandas as pd
import plotly.graph_objs as go
from datetime import datetime
from sympy import symbols, Eq, solve

def download_data(ticker, period):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        df['Date'] = pd.to_datetime(df['Date'])
        df.set_index('Date', inplace=True)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")
    return df

def plot_data_with_trend_lines(df, ticker):
    # Create candlestick trace
    trace = go.Candlestick(
        x=df.index,
        open=df['Open'],
        high=df['High'],
        low=df['Low'],
        close=df['Close'],
        name='Candlesticks'
    )

    # Set up the Plotly figure
    fig = go.Figure(trace)

    # Find the highest resistance level in the last 30 days and add a trend line
    highest_resistance_date = df.last('30D')['Close'].idxmax()
    highest_resistance_value = df.last('30D')['Close'].max()

    fig.add_trace(go.Scatter(x=[df.index[0], df.index[-1]],
                             y=[highest_resistance_value, highest_resistance_value],
                             mode='lines', line=dict(color='red'), name='Resistance'))

    # Find the lowest support level in the last 30 days and add a trend line
    lowest_support_date = df.last('30D')['Close'].idxmin()
    lowest_support_value = df.last('30D')['Close'].min()

    fig.add_trace(go.Scatter(x=[df.index[0], df.index[-1]],
                             y=[lowest_support_value, lowest_support_value],
                             mode='lines', line=dict(color='green'), name='Support'))

    # Add layout and show figure
    fig.update_layout(title=f"{ticker} Trend Line Analysis", xaxis_title='Date', yaxis_title='Price')
    fig.show()

def plot_data_with_trend_lines_ORIGINAL(df, ticker):
    # Create candlestick trace
    trace = go.Candlestick(
        x=df.index,
        open=df['Open'],
        high=df['High'],
        low=df['Low'],
        close=df['Close'],
        name='Candlesticks'
    )

    # Set up the Plotly figure
    fig = go.Figure(trace)

    # Find the highest resistance level in the last 30 days and add a trend line
    highest_resistance_date = df.last('30D')['Close'].idxmax()
    highest_resistance_value = df.last('30D')['Close'].max()

    fig.add_trace(go.Scatter(x=[highest_resistance_date, df.index[-1]],
                             y=[highest_resistance_value, highest_resistance_value],
                             mode='lines', line=dict(color='red'), name='Resistance'))

    # Find the lowest support level in the last 30 days and add a trend line
    lowest_support_date = df.last('30D')['Close'].idxmin()
    lowest_support_value = df.last('30D')['Close'].min()

    fig.add_trace(go.Scatter(x=[lowest_support_date, df.index[-1]],
                             y=[lowest_support_value, lowest_support_value],
                             mode='lines', line=dict(color='green'), name='Support'))

    # Add layout and show figure
    fig.update_layout(title=f"{ticker} Trend Line Analysis", xaxis_title='Date', yaxis_title='Price')
    fig.show()

def main():
    #ticker = ticker  # Replace with desired ticker
    #period = period
    df = download_data(ticker, period)
    plot_data_with_trend_lines(df, ticker)

if __name__ == '__main__':
    main()

#@title : just downtrend for last six months :
import os
import yfinance as yf
import pandas as pd
import plotly.graph_objs as go
from datetime import datetime

def download_data(ticker, period):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        df['Date'] = pd.to_datetime(df['Date'])
        df.set_index('Date', inplace=True)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")
    return df

def plot_data_with_downtrend_line(df, ticker):
    # Create candlestick trace
    trace = go.Candlestick(
        x=df.index,
        open=df['Open'],
        high=df['High'],
        low=df['Low'],
        close=df['Close'],
        name='Candlesticks'
    )

    # Set up the Plotly figure
    fig = go.Figure(trace)

    # Find the highest value in the last six months
    highest_value_date = df.last('6M')['Close'].idxmax()
    highest_value = df.last('6M')['Close'].max()

    # Add the downtrend line from the highest value to today's candle
    fig.add_trace(go.Scatter(x=[highest_value_date, df.index[-1]],
                             y=[highest_value, df['Close'][-1]],
                             mode='lines', line=dict(color='red'), name='Downtrend Line'))

    # Add layout and show figure
    fig.update_layout(title=f"{ticker} Downtrend Line Analysis", xaxis_title='Date', yaxis_title='Price')
    fig.show()

def main():
    #ticker = ticker  # Replace with desired ticker
    #period = period
    df = download_data(ticker, period)
    plot_data_with_downtrend_line(df, ticker)

if __name__ == '__main__':
    main()

#@title : up or downtrend
import os
import yfinance as yf
import pandas as pd
import plotly.graph_objs as go
from datetime import datetime

def download_data(ticker, period):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        df['Date'] = pd.to_datetime(df['Date'])
        df.set_index('Date', inplace=True)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")
    return df

def plot_data_with_dominant_trend_line(df, ticker):
    # Create candlestick trace
    trace = go.Candlestick(
        x=df.index,
        open=df['Open'],
        high=df['High'],
        low=df['Low'],
        close=df['Close'],
        name='Candlesticks'
    )

    # Set up the Plotly figure
    fig = go.Figure(trace)

    # Find the highest value in the last six months
    highest_value_date = df.last('6M')['Close'].idxmax()
    highest_value = df.last('6M')['Close'].max()

    # Find the lowest value in the last six months
    lowest_value_date = df.last('6M')['Close'].idxmin()
    lowest_value = df.last('6M')['Close'].min()

    # Determine the dominant trend based on the highest and lowest values
    if highest_value_date > lowest_value_date:
        # Uptrend
        fig.add_trace(go.Scatter(x=[highest_value_date, df.index[-1]],
                                 y=[highest_value, df['Close'][-1]],
                                 mode='lines', line=dict(color='green'), name='Uptrend Line'))
    else:
        # Downtrend
        fig.add_trace(go.Scatter(x=[lowest_value_date, df.index[-1]],
                                 y=[lowest_value, df['Close'][-1]],
                                 mode='lines', line=dict(color='red'), name='Downtrend Line'))

    # Add layout and show figure
    fig.update_layout(title=f"{ticker} Dominant Trend Line Analysis", xaxis_title='Date', yaxis_title='Price')
    fig.show()

def main():
    #ticker = ticker  # Replace with desired ticker
    #eriod = period
    df = download_data(ticker, period)
    plot_data_with_dominant_trend_line(df, ticker)

if __name__ == '__main__':
    main()

import os
import yfinance as yf
import pandas as pd
import matplotlib.pyplot as plt
from datetime import datetime
import matplotlib.gridspec as gridspec

def download_data(ticker, period):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        df['Date'] = pd.to_datetime(df['Date'])
        df.set_index('Date', inplace=True)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")
    return df

def normalize_data(df):
    return (df["Close"] - df["Close"].mean()) / df["Close"].std()

def plot_commodities(commodities, period=period):
    n_commodities = len(commodities)
    n_cols = 4
    n_rows = (n_commodities + n_cols - 1) // n_cols

    fig = plt.figure(figsize=(20, 5 * n_rows))
    gs = gridspec.GridSpec(n_rows, n_cols, figure=fig)

    for i, (name, ticker) in enumerate(commodities.items()):
        df = download_data(ticker, period)
        norm_data = normalize_data(df)

        ax = fig.add_subplot(gs[i])
        ax.plot(norm_data, label=name)
        ax.set_title(name)
        ax.legend()

    plt.tight_layout()
    plt.show()

def main():
    commodities = {
        "Light Sweet Crude Oil": "CL=F",
        "Brent Crude Oil": "BZ=F",
        "Natural Gas": "NG=F",
        "Heating Oil": "HO=F",
        "RBOB Gasoline": "RB=F",
        "Gold": "GC=F",
        "Silver": "SI=F",
        "Copper": "HG=F",
        "Platinum": "PL=F",
        "Palladium": "PA=F",
        "Corn": "ZC=F",
        "Wheat": "ZW=F",
        "Soybeans": "ZS=F",
        "Soybean Oil": "ZL=F",
        "Soybean Meal": "ZM=F",
        "Sugar": "SB=F",
        "Coffee": "KC=F",
        "Cocoa": "CC=F",
        "Cotton": "CT=F",
        "Orange Juice": "OJ=F",
        "Live Cattle": "LE=F",
        "Lean Hogs": "HE=F",
        "Feeder Cattle": "GF=F"
    }

    plot_commodities(commodities)

if __name__ == '__main__':
    main()

import os
import yfinance as yf
import pandas as pd
import matplotlib.pyplot as plt
from datetime import datetime

def download_data(ticker, period):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        df['Date'] = pd.to_datetime(df['Date'])
        df.set_index('Date', inplace=True)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")
    return df

def normalize_data(df):
    return (df["Close"] - df["Close"].mean()) / df["Close"].std()

def plot_grouped_commodities(groups, period=period):
    fig, axs = plt.subplots(2, 2, figsize=(20, 15))
    axs = axs.flatten()
    group_titles = ["Energy", "Metals", "Agriculture", "Livestock"]

    for i, (group_name, commodities) in enumerate(groups.items()):
        for name, ticker in commodities.items():
            df = download_data(ticker, period)
            norm_data = normalize_data(df)
            axs[i].plot(norm_data, label=name)
        axs[i].set_title(group_titles[i])
        axs[i].legend()

    plt.tight_layout()
    plt.show()

def main():
    commodity_groups = {
        "Energy": {
            "Light Sweet Crude Oil": "CL=F",
            "Brent Crude Oil": "BZ=F",
            "Natural Gas": "NG=F",
            "Heating Oil": "HO=F",
            "RBOB Gasoline": "RB=F"
        },
        "Metals": {
            "Gold": "GC=F",
            "Silver": "SI=F",
            "Copper": "HG=F",
            "Platinum": "PL=F",
            "Palladium": "PA=F"
        },
        "Agriculture": {
            "Corn": "ZC=F",
            "Wheat": "ZW=F",
            "Soybeans": "ZS=F",
            "Soybean Oil": "ZL=F",
            "Soybean Meal": "ZM=F",
            "Sugar": "SB=F",
            "Coffee": "KC=F",
            "Cocoa": "CC=F",
            "Cotton": "CT=F",
            "Orange Juice": "OJ=F"
        },
        "Livestock": {
            "Live Cattle": "LE=F",
            "Lean Hogs": "HE=F",
            "Feeder Cattle": "GF=F"
        }
    }

    plot_grouped_commodities(commodity_groups)

if __name__ == '__main__':
    main()

#NEW PARTS FOR CORRELATIONS :
import os
import yfinance as yf
import pandas as pd
import matplotlib.pyplot as plt
from datetime import datetime

def download_data(ticker, period):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        df['Date'] = pd.to_datetime(df['Date'])
        df.set_index('Date', inplace=True)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")
    return df

def normalize_data(df):
    return (df["Close"] - df["Close"].mean()) / df["Close"].std()

def plot_normalized_data(df):
    plt.figure(figsize=(12, 6))
    plt.title("Normalized Lean Hogs vs. Corn Futures Performance")
    plt.plot(df)
    plt.legend(df.columns)
    plt.show()

def main():
    # Define tickers and period
    he_ticker = "HE=F"
    zc_ticker = "ZC=F"
    #period = "1y"

    # Download and prepare data
    he_data = download_data(he_ticker, period)
    zc_data = download_data(zc_ticker, period)

    # Normalize data
    he_norm = normalize_data(he_data)
    zc_norm = normalize_data(zc_data)

    # Combine normalized data
    df = pd.concat([he_norm, zc_norm], axis=1)
    df.columns = ["Lean Hogs", "Corn"]

    # Plot the data
    plot_normalized_data(df)

if __name__ == '__main__':
    main()

import os
import yfinance as yf
import pandas as pd
import matplotlib.pyplot as plt
from datetime import datetime

def download_data(ticker, period):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        df['Date'] = pd.to_datetime(df['Date'])
        df.set_index('Date', inplace=True)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")
    return df

def normalize_data(df):
    return (df["Close"] - df["Close"].mean()) / df["Close"].std()

#def plot_grouped_commodities(groups, period=period):
def plot_grouped_commodities(groups, period=period):
    n_groups = len(groups)
    fig, axs = plt.subplots((n_groups + 1) // 2, 2, figsize=(20, 5 * ((n_groups + 1) // 2)))
    axs = axs.flatten()
    group_titles = list(groups.keys())

    for i, (group_name, commodities) in enumerate(groups.items()):
        for name, ticker in commodities.items():
            df = download_data(ticker, period)
            norm_data = normalize_data(df)
            axs[i].plot(norm_data, label=name)
        axs[i].set_title(group_titles[i])
        axs[i].legend()

    plt.tight_layout()
    plt.show()

def main():
    commodity_groups = {
        "Energy": {
            "Light Sweet Crude Oil": "CL=F",
            "Brent Crude Oil": "BZ=F",
            "Natural Gas": "NG=F",
            "Heating Oil": "HO=F",
            "RBOB Gasoline": "RB=F"
        },
        "Metals": {
            "Gold": "GC=F",
            "Silver": "SI=F",
            "Copper": "HG=F",
            "Platinum": "PL=F",
            "Palladium": "PA=F"
        },
        "Livestock": {
            "Live Cattle": "LE=F",
            "Lean Hogs": "HE=F",
            "Feeder Cattle": "GF=F"
        },
        "Grains": {
            "Corn": "ZC=F",
            "Wheat": "ZW=F",
            "Soybeans": "ZS=F",
            "Soybean Meal": "ZM=F"
        },
        "Oilseeds (and Derivatives)": {
            "Soybeans": "ZS=F",
            "Soybean Oil": "ZL=F"
        },
        "Softs": {
            "Sugar": "SB=F",
            "Coffee": "KC=F",
            "Cocoa": "CC=F",
            "Cotton": "CT=F",
            "Orange Juice": "OJ=F"
        }
    }

    plot_grouped_commodities(commodity_groups)

if __name__ == '__main__':
    main()

import os
import yfinance as yf
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime

def download_data(ticker, period):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        df['Date'] = pd.to_datetime(df['Date'])
        df.set_index('Date', inplace=True)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")
    return df

def normalize_data(df):
    return (df["Close"] - df["Close"].mean()) / df["Close"].std()

def create_correlation_matrix(commodities, period=period):
    all_data = {}

    for group in commodities.values():
        for name, ticker in group.items():
            df = download_data(ticker, period)
            norm_data = normalize_data(df)
            all_data[name] = norm_data

    combined_df = pd.DataFrame(all_data)

    correlation_matrix = combined_df.corr()

    plt.figure(figsize=(12, 10))
    #sns.heatmap(correlation_matrix, annot=True, cmap="RdBu", center=0, vmin=-1, vmax=1)
    #sns.heatmap(correlation_matrix, annot=True, cmap="RdBu", center=0, vmin=-1, vmax=1,
    #            linewidths=.6, annot_kws={"size": 6})  # Changes here
    #sns.heatmap(correlation_matrix, annot=True, cmap="RdBu", center=0, vmin=-1, vmax=1,
    #        annot_kws={"size": 7, "color": "black"})  # No linewidths
    #sns.heatmap(correlation_matrix, annot=True, cmap="RdBu", center=0, vmin=-1, vmax=1,
    #        annot_kws={"size": 6, "color": "black"})
    #sns.heatmap(correlation_matrix, annot=True, cmap="RdBu", center=0, vmin=-1, vmax=1,
    #          annot_kws={"size": 6, "color": "black"}, fmt=".2f", linewidths=0)
    sns.heatmap(correlation_matrix, annot=True, cmap="RdBu", center=0, vmin=-1, vmax=1,
                annot_kws={"size": 6, "color": "black"}, fmt=".2f", linewidths=0)
    sns.set(rc={'axes.facecolor':'white', 'figure.facecolor':'white'}) # added line



    plt.title("Correlation Matrix of Commodities")
    plt.show()

def main():
    commodity_groups = {
        "Energy": {
            "Light Sweet Crude Oil": "CL=F",
            "Brent Crude Oil": "BZ=F",
            "Natural Gas": "NG=F",
            "Heating Oil": "HO=F",
            "RBOB Gasoline": "RB=F"
        },
        "Metals": {
            "Gold": "GC=F",
            "Silver": "SI=F",
            "Copper": "HG=F",
            "Platinum": "PL=F",
            "Palladium": "PA=F"
        },
        "Livestock": {
            "Live Cattle": "LE=F",
            "Lean Hogs": "HE=F",
            "Feeder Cattle": "GF=F"
        },
        "Grains": {
            "Corn": "ZC=F",
            "Wheat": "ZW=F",
            "Soybeans": "ZS=F",
            "Soybean Meal": "ZM=F"
        },
        "Oilseeds (and Derivatives)": {
            "Soybeans": "ZS=F",
            "Soybean Oil": "ZL=F"
        },
        "Softs": {
            "Sugar": "SB=F",
            "Coffee": "KC=F",
            "Cocoa": "CC=F",
            "Cotton": "CT=F",
            "Orange Juice": "OJ=F"
        },
        "STOCK": {
            "SPY": "SPY",
            "DIS": "DIS"

        }
    }

    create_correlation_matrix(commodity_groups)

if __name__ == '__main__':
    main()

import os
import yfinance as yf
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime

def download_data(ticker, period):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        df['Date'] = pd.to_datetime(df['Date'])
        df.set_index('Date', inplace=True)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")
    return df

def normalize_data(df):
    return (df["Close"] - df["Close"].mean()) / df["Close"].std()

def create_correlation_matrix(etfs, period=period):
    all_data = {}

    for name, ticker in etfs.items():
        df = download_data(ticker, period)
        norm_data = normalize_data(df)
        all_data[name] = norm_data

    combined_df = pd.DataFrame(all_data)

    correlation_matrix = combined_df.corr()

    plt.figure(figsize=(20, 15))
    #sns.heatmap(correlation_matrix, annot=True, cmap="coolwarm", center=0, vmin=-1, vmax=1)
    sns.heatmap(correlation_matrix, annot=True, cmap="RdBu", center=0, vmin=-1, vmax=1,  linewidths=0, linecolor='none',  annot_kws={"size": 6})  # Changes here


    plt.title("Correlation Matrix of ETFs")
    plt.show()

def main():
    etfs = {
        # Equities
        "PEP": "PEP",
        "KO": "KO",
        "DIS": "DIS",
        "SPY": "SPY",
        "IVV": "IVV",
        "VTI": "VTI",
        "DIA": "DIA",
        "VOO": "VOO",
        "IWM": "IWM",
        "MDY": "MDY",
        "XLB": "XLB",
        "XLC": "XLC",
        "XLE": "XLE",
        "XLF": "XLF",
        "XLI": "XLI",
        "XLK": "XLK",
        "XLP": "XLP",
        "XLRE": "XLRE",
        "XLU": "XLU",
        "XLV": "XLV",
        "XLY": "XLY",
        "EEM": "EEM",
        "EFA": "EFA",
        "EWJ": "EWJ",
        "EWW": "EWW",
        # Bonds
        "TLT": "TLT",
        "IEF": "IEF",
        "SHY": "SHY",
        "AGG": "AGG",
        "HYG": "HYG",
        "LQD": "LQD",
        # Real Estate
        "VNQ": "VNQ",
        "IYR": "IYR",
        # Commodities
        "DBC": "DBC",
        "GLD": "GLD",
        "SLV": "SLV",
        "PPLT": "PPLT",
        "UNG": "UNG",
        "DBA": "DBA",
        # Currency
        "UUP": "UUP",
        # Inflation
        "TIP": "TIP",
        # Volatility
        "VXX": "VXX",
        # Additional ETFs
        "JETS": "JETS",
        "PEJ": "PEJ",
        "CRUZ": "CRUZ",
        "VDC": "VDC",
        "RXI": "RXI",
        "BITO": "BITO"
    }

    create_correlation_matrix(etfs)

if __name__ == '__main__':
    main()



import os
import yfinance as yf
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime

def download_data(ticker, period):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        df['Date'] = pd.to_datetime(df['Date'])
        df.set_index('Date', inplace=True)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")
    return df

def normalize_data(df):
    return (df["Close"] - df["Close"].mean()) / df["Close"].std()

def create_correlation_matrix(etfs, period=period):
    all_data = {}

    for name, ticker in etfs.items():
        df = download_data(ticker, period)
        norm_data = normalize_data(df)
        all_data[name] = norm_data

    combined_df = pd.DataFrame(all_data)

    correlation_matrix = combined_df.corr()

    plt.figure(figsize=(20, 15))
    #sns.heatmap(correlation_matrix, annot=True, cmap="coolwarm", center=0, vmin=-1, vmax=1)
    sns.heatmap(correlation_matrix, annot=True, cmap="RdBu", center=0, vmin=-1, vmax=1,  linewidths=0, linecolor='none',  annot_kws={"size": 6})  # Changes here


    plt.title("Correlation Matrix of ETFs")
    plt.show()

def main():
    cryptos = {
        # crypto
        "BTC-USD":"BTC-USD",
        "ETH-USD":"ETH-USD",
        "USDT-USD":"USDT-USD",
        "BNB-USD":"BNB-USD",
        "SOL-USD": "SOL-USD",
        "STETH-USD": "STETH-USD",
        "USDC-USD": "USDC-USD",
        "XRP-USD": "XRP-USD",
        "DOGE-USD": "DOGE-USD",
        "ADA-USD": "ADA-USD",
        "AVAX-USD": "AVAX-USD",
        "SHIB-USD": "SHIB-USD",
        "DOT-USD": "DOT-USD",
        "WBTC-USD": "WBTC-USD",
        "TRX-USD": "TRX-USD",
        "WTRX-USD": "WTRX-USD",
        "BCH-USD": "BCH-USD",
        "LINK-USD": "LINK-USD",
        "NEAR-USD": "NEAR-USD",
        "MATIC-USD": "MATIC-USD",
        "LTC-USD": "LTC-USD",
        "ICP-USD": "ICP-USD",
        "PEPE24478-USD": "PEPE24478-USD",
        "UNI7083-USD":"UNI7083-USD"
    }

    create_correlation_matrix(cryptos)

if __name__ == '__main__':
    main()

import os
import yfinance as yf
import pandas as pd
import matplotlib.pyplot as plt
from datetime import datetime

def download_data(ticker, period=period):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        df['Date'] = pd.to_datetime(df['Date'])
        df.set_index('Date', inplace=True)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        df = yf.download(ticker, period=period)
        df.to_csv(data_file)
        print(f"Data for {ticker} downloaded and saved to disk.")

    if 'Close' not in df.columns:
        raise ValueError(f"Data for {ticker} does not contain 'Close' prices.")

    return df

def normalize_data(df):
    df_normalized = df.copy()
    df_normalized["Close"] = (df["Close"] - df["Close"].mean()) / df["Close"].std()
    return df_normalized

def calculate_price_ratio(df1, df2):
    return df1["Close"] / df2["Close"]

def calculate_daily_pair_correlation(df1, df2):
    return df1["Close"].pct_change().rolling(window=20).corr(df2["Close"].pct_change())

def plot_comparison(ticker1, ticker2, period=period):
    df1 = download_data(ticker1, period)
    df2 = download_data(ticker2, period)

    norm_df1 = normalize_data(df1)
    norm_df2 = normalize_data(df2)

    price_ratio = calculate_price_ratio(df1, df2)
    pair_correlation = calculate_daily_pair_correlation(df1, df2)

    fig, axs = plt.subplots(2, 2, figsize=(14, 10))

    # Plot 1: Normalized closing prices
    axs[0, 0].plot(norm_df1.index, norm_df1["Close"], label=ticker1)
    axs[0, 0].plot(norm_df2.index, norm_df2["Close"], label=ticker2)
    axs[0, 0].set_title(f'Normalized Prices: {ticker1} vs {ticker2}')
    axs[0, 0].legend()

    # Plot 2: Relative performance (normalized)
    axs[0, 1].plot(norm_df1.index, norm_df1["Close"] - norm_df2["Close"], label=f'{ticker1} - {ticker2}')
    axs[0, 1].set_title(f'Relative Performance: {ticker1} - {ticker2}')
    axs[0, 1].legend()

    # Plot 3: Price ratio
    axs[1, 0].plot(df1.index, price_ratio, label=f'{ticker1}/{ticker2}')
    axs[1, 0].set_title(f'Price Ratio: {ticker1}/{ticker2}')
    axs[1, 0].legend()

    # Plot 4: Daily pair correlation
    axs[1, 1].plot(df1.index, pair_correlation, label=f'{ticker1} & {ticker2} Correlation')
    axs[1, 1].set_title(f'Daily Pair Correlation: {ticker1} & {ticker2}')
    axs[1, 1].legend()

    plt.tight_layout()
    plt.show()

def main():
    ticker1 = "KO"  # Example input for the first ETF or commodity
    ticker2 = "PEP"  # Example input for the second ETF or commodity
    #period = period  # You can adjust the period as needed

    plot_comparison(ticker1, ticker2, period)

if __name__ == '__main__':
    main()

import os
import yfinance as yf
import pandas as pd
import matplotlib.pyplot as plt
from datetime import datetime

def download_data(ticker, period):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        df['Date'] = pd.to_datetime(df['Date'])
        df.set_index('Date', inplace=True)
        print(f"Data for {ticker} found on disk.")
    except FileNotFoundError:
        try:
            df = yf.download(ticker, period=period)
            df.to_csv(data_file)
            print(f"Data for {ticker} downloaded and saved to disk.")
        except Exception as e:
            print(f"Error downloading data for {ticker}: {e}")
            return None

    if 'Close' not in df.columns:
        raise ValueError(f"Data for {ticker} does not contain 'Close' prices.")

    return df

def normalize_data(df):
    df_normalized = df.copy()
    df_normalized["Close"] = (df["Close"] - df["Close"].mean()) / df["Close"].std()
    return df_normalized

def calculate_price_ratio(df1, df2):
    return df1["Close"] / df2["Close"]

def calculate_daily_pair_correlation(df1, df2):
    return df1["Close"].pct_change().rolling(window=20).corr(df2["Close"].pct_change())

def plot_comparison(ticker1, ticker2, period):
    df1 = download_data(ticker1, period)
    df2 = download_data(ticker2, period)

    if df1 is None or df2 is None:
        print("Error: One or both datasets could not be downloaded.")
        return

    norm_df1 = normalize_data(df1)
    norm_df2 = normalize_data(df2)

    price_ratio = calculate_price_ratio(df1, df2)
    pair_correlation = calculate_daily_pair_correlation(df1, df2)

    fig, axs = plt.subplots(3, 2, figsize=(14, 15))

    # Plot 1: Normalized closing prices
    axs[0, 0].plot(norm_df1.index, norm_df1["Close"], label=ticker1)
    axs[0, 0].plot(norm_df2.index, norm_df2["Close"], label=ticker2)
    axs[0, 0].set_title(f'Normalized Prices: {ticker1} vs {ticker2}')
    axs[0, 0].legend()

    # Plot 2: Relative performance (normalized)
    axs[0, 1].plot(norm_df1.index, norm_df1["Close"] - norm_df2["Close"], label=f'{ticker1} - {ticker2}')
    axs[0, 1].set_title(f'Relative Performance: {ticker1} - {ticker2}')
    axs[0, 1].legend()

    # Plot 3: Price ratio
    axs[1, 0].plot(df1.index, price_ratio, label=f'{ticker1}/{ticker2}')
    axs[1, 0].set_title(f'Price Ratio: {ticker1}/{ticker2}')
    axs[1, 0].legend()

    # Plot 4: Daily pair correlation
    axs[1, 1].plot(df1.index, pair_correlation, label=f'{ticker1} & {ticker2} Correlation')
    axs[1, 1].set_title(f'Daily Pair Correlation: {ticker1} & {ticker2}')
    axs[1, 1].legend()

    # Plot 5: Percentage change
    axs[2, 0].plot(df1.index, df1['Close'].pct_change() * 100, label=ticker1)
    axs[2, 0].plot(df2.index, df2['Close'].pct_change() * 100, label=ticker2)
    axs[2, 0].set_title(f'Percentage Change: {ticker1} vs {ticker2}')
    axs[2, 0].legend()

    plt.tight_layout()
    plt.show()

def main():
    ticker1 = "KO"  # Example input for the first ETF or commodity
    ticker2 = "PEP"  # Example input for the second ETF or commodity
    #period = '1y'  # You can adjust the period as needed

    plot_comparison(ticker1, ticker2, period)

if __name__ == '__main__':
    main()

# EXPLANATION OF INDICATORS :
'''
Bollinger Bands (BBANDS): Consist of an upper, middle, and lower band, which are used to measure market volatility and overbought/oversold conditions.
Average Directional Index (ADX): Measures the strength of a trend; values above 20-25 often indicate a strong trend.
Standard Deviation (STDDEV): Quantifies the amount of variation or dispersion in a set of values, commonly used for volatility assessment.
Average True Range (ATR): Provides an indication of the volatility of an asset by measuring the range of each candle/bar.
Chande Momentum Oscillator (CMO): Indicates overbought or oversold conditions by comparing the sum of gains and losses over a specified period.
Rate of Change (ROC): Measures the percentage change in price between the current price and the price a certain number of periods ago.
Stochastic Oscillator (STOCH): Momentum indicator comparing a particular closing price of a security to a range of its prices over a certain period.
Williams Percent Range (WILLR): Momentum indicator that identifies overbought and oversold levels.
Linear Regression Slope (LR_Slope): Indicates the direction and strength of a trend by calculating the slope of the regression line.
Accumulation/Distribution Line (AD): Volume-based indicator designed to measure the cumulative flow of money into and out of a security.
Chaikin A/D Oscillator (ADOSC): Momentum indicator that measures the difference between the Accumulation/Distribution Line and its moving average.
Average Directional Movement Index Rating (ADXR): A smoothed version of ADX, used to determine the strength of a trend over time.
Absolute Price Oscillator (APO): A momentum oscillator that subtracts a longer-term moving average from a shorter-term moving average.
Aroon Indicator (AROON): Used to identify when trends are likely to start and whether a stock is trending or not.
Aroon Oscillator (AROONOSC): Subtracts the Aroon Down from the Aroon Up to measure the strength of a trend.
Average Price (AVGPRICE): Simply the average of the open, high, low, and close for a given period.
Beta (BETA): Measures the volatility or systematic risk of a stock in comparison to the market as a whole.
Balance of Power (BOP): Measures the strength of buying and selling pressure and can be used to confirm trends.
Pearson's Correlation Coefficient (CORREL): Measures the linear relationship between two variables or datasets.
Double Exponential Moving Average (DEMA): Attempts to remove the inherent lag associated with Moving Averages by placing more weight on recent data.
Directional Movement Index (DX): Identifies the strength of price movement in a positive or negative direction.
Hilbert Transform - Dominant Cycle Period (HT_DCPERIOD): Estimates the period of the dominant cycle in the price data, helping to identify cyclical patterns.
Hilbert Transform - Dominant Cycle Phase (HT_DCPHASE): Determines the phase of the dominant market cycle, aiding in cycle analysis.
Hilbert Transform - Phasor Components (HT_PHASOR): Extracts the in-phase and quadrature components of the price cycle, offering insights into market cycles and trends.
Hilbert Transform - SineWave (HT_SINE): Generates sine and lead sine waves to predict the cyclical turning points of a market.
Hilbert Transform - Instantaneous Trendline (HT_TRENDLINE): Smooth trendline that can adapt to market movements more quickly than traditional moving averages.
Hilbert Transform - Trend vs Cycle Mode (HT_TRENDMODE): Indicates whether the market is trending or in a cycle mode, helping distinguish between trending and cyclical phases.
Kaufman Adaptive Moving Average (KAMA): Adjusts its sensitivity to price movements based on the volatility of the market.
Linear Regression (LINEARREG): Indicates the central tendency of the price over a specified period, showing the trend line.
Linear Regression Angle (LINEARREG_ANGLE): Measures the angle of the linear regression line, indicating the strength of the trend.
Linear Regression Intercept (LINEARREG_INTERCEPT): The point where the linear regression line intersects the Y-axis, providing insight into market levels.
Linear Regression Slope (LINEARREG_SLOPE): Indicates the steepness of the linear regression line, reflecting the rate of price change.
Moving Average (MA): Averages the prices over a specified number of periods, smoothing out price data to identify the trend direction.
Moving Average Convergence Divergence - Extended (MACDEXT): Similar to MACD but allows for different settings for the fast, slow, and signal line moving averages, enhancing flexibility.
Moving Average Convergence Divergence Fix 12/26 (MACDFIX): A specific type of MACD indicator with fixed periods of 12 and 26, used for trend following and momentum.
MESA Adaptive Moving Average (MAMA): Adapts to price movement based on the rate of change of phase as measured by the Hilbert Transform Discriminator, allowing for faster reaction to price changes.
Momentum (MOM): Measures the rate of change in prices, indicating the strength of price movements.
Normalized Average True Range (NATR): Expresses the Average True Range (ATR) as a percentage of the closing price, normalizing the range for comparability across different price levels.
Plus Directional Indicator (PLUS_DI): Part of the Average Directional Index (ADX) system, shows the strength of upward price movements.
Plus Directional Movement (PLUS_DM): Measures the positive movement between two periods, contributing to the calculation of ADX for trend strength assessment
Percentage Price Oscillator (PPO): Shows the relative relationship between two moving averages, indicating momentum and potential trend reversals, similar to MACD but expressed as a percentage.
Rate of Change Percentage (ROCP): Measures the percentage change in price between the current price and the price from a certain number of periods ago, highlighting the speed of price movement.
Rate of Change Ratio (ROCR): Compares the current price with a price "n" periods ago, providing insights into the relative strength of price movements.
Rate of Change Ratio 100 Scale (ROCR100): Similar to ROCR but scaled to multiply by 100, making it easier to identify the strength of the trend.
Parabolic SAR - Extended (SAREXT): Provides stop-loss levels for both sides of the market, extending the capabilities of the standard Parabolic SAR for more flexibility in trend-following strategies.
Simple Moving Average (SMA): Calculates the average of a selected range of prices, usually closing prices, by the number of periods in that range, often used to identify trend direction.
Stochastic Fast (STOCHF): A faster version of the Stochastic Oscillator, sensitive to market movements and used to identify overbought and oversold conditions.
Stochastic Relative Strength Index (STOCHRSI): Combines the Stochastic Oscillator and Relative Strength Index (RSI) to produce a more sensitive indicator that identifies overbought and oversold conditions.
Triple Exponential Moving Average (T3): Applies multiple exponential smoothing to reduce lag in the data, often used to identify the trend more clearly.
Triple Exponential Moving Average (TEMA): Attempts to eliminate lag in moving averages by placing more weight on recent prices, suitable for identifying trends and potential reversals.
Triangular Moving Average (TRIMA): Averages the prices over a specified period and then averages them again, producing a smoothed indicator that highlights the trend.
1-day Rate-Of-Change (ROC) of a Triple Smooth EMA (TRIX): Shows the rate of change of a triple exponentially smoothed moving average, helping to identify overbought or oversold conditions in the trend's momentum.
Time Series Forecast (TSF): Projects future price movement based on a linear regression of the prices, offering insights into potential trend directions.
Typical Price (TYPPRICE): Represents the average of the high, low, and close for a period, providing a simplified view of price action.
Variance (VAR): Measures the variability of price movements, indicating market volatility and potential price dispersion.
Weighted Close Price (WCLPRICE): Gives more weight to the closing price, combining the high, low, and double the close, then dividing by four, offering a perspective on the closing strength.
Weighted Moving Average (WMA): Places more importance on recent prices, aiming to reduce lag in the data and respond more quickly to market changes.
'''

import yfinance as yf
import pandas as pd
import plotly.graph_objects as go
import os
from datetime import datetime, timedelta

# --- Configuration ---
#ticker = 'NVDA'
myWeeks = 0
period = "1d"

# --- Data Directories ---
def get_data_directory(ticker):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    return data_dir

# --- Option Data Handling ---
def download_options_data(ticker, date):
    data_dir = get_data_directory(ticker)
    data_file = f"{data_dir}/options.{date}.{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        print(f"Options data for {ticker} found on disk.")
    except FileNotFoundError:
        stock = yf.Ticker(ticker)
        options = stock.option_chain(date.strftime("%Y-%m-%d"))
        df = pd.concat([options.calls, options.puts])
        df.to_csv(data_file)
        print(f"Options data for {ticker} downloaded and saved to disk.")

    return df

# --- Find Nearest Expiration ---
def get_nearest_expiration(ticker, target_date):
    stock = yf.Ticker(ticker)
    options_dates = stock.options
    nearest_date_str = min(options_dates, key=lambda d: abs(datetime.strptime(d, "%Y-%m-%d") - target_date))
    return datetime.strptime(nearest_date_str, "%Y-%m-%d")

# --- Main Plotting Logic ---
def create_plot(calls_data, puts_data, current_price, nearest_date):
    # Separate figures for calls and puts
    fig_calls = go.Figure(go.Scatter(x=calls_data['openInterest'], y=calls_data['strike'], mode='lines', name='Call Options'))
    fig_puts = go.Figure(go.Scatter(x=puts_data['openInterest'], y=puts_data['strike'], mode='lines', name='Put Options'))

    # Customize individual figures
    for fig in [fig_calls, fig_puts]:
        fig.update_layout(
            xaxis_title="Open Interest",
            yaxis_title="Strike Price",
            plot_bgcolor='black',
            paper_bgcolor='black',
            font=dict(color='white'),
            xaxis=dict(showgrid=True, gridcolor='gray', gridwidth=0.5),
            yaxis=dict(showgrid=True, gridcolor='gray', gridwidth=0.5)
        )

        # Add vertical line for the current price
        fig.add_shape(type='line', x0=0, y0=current_price, x1=max(calls_data['openInterest'].max(), puts_data['openInterest'].max()), y1=current_price,
                      line=dict(color='green', width=2, dash='dash'))

    # Combine the subplots
    fig = go.Figure()
    fig.add_trace(fig_calls.data[0])
    fig.add_trace(fig_puts.data[0])

    # Update combined layout
    fig.update_layout(
        title=f"Ticker: {ticker}<br>Expiration 0DTE<br>Levels for {nearest_date}",
        height=800,
        showlegend=False
    )

    # ... (Add annotations here as needed, adjusting positions for the new layout)

    return fig

# --- Main Execution ---
target_date = datetime.today() + timedelta(weeks=myWeeks)

try:
    nearest_date = get_nearest_expiration(ticker, target_date)
except ValueError:
    print(f"No options available for {ticker}. Exiting.")
    exit()

current_price = yf.Ticker(ticker).history(period=period)['Close'].iloc[-1]
options_data = download_options_data(ticker, nearest_date)
calls_data = options_data[options_data['contractSymbol'].str.contains('C')]
puts_data = options_data[options_data['contractSymbol'].str.contains('P')]

fig = create_plot(calls_data, puts_data, current_price, nearest_date)
fig.show()

import yfinance as yf
import pandas as pd
import plotly.graph_objects as go
import os
from datetime import datetime, timedelta

# --- Configuration ---
ticker = 'NVDA'
myWeeks = 0
period = "1d"

# --- ... (rest of the functions are the same) ---

# --- Main Plotting Logic ---
def create_plot(calls_data, puts_data, current_price, nearest_date):
    fig = go.Figure()

    # Add traces for calls and puts
    fig.add_trace(go.Scatter(x=calls_data['strike'], y=calls_data['openInterest'], mode='lines', name='Call Options'))
    fig.add_trace(go.Scatter(x=puts_data['strike'], y=puts_data['openInterest'], mode='lines', name='Put Options'))

    # ... (rest of your plotting logic) ...

    return fig  # Ensure the figure is returned

# --- Main Execution ---
target_date = datetime.today() + timedelta(weeks=myWeeks)

try:
    nearest_date = get_nearest_expiration(ticker, target_date)
except ValueError:
    print(f"No options available for {ticker}. Exiting.")
    exit()

current_price = yf.Ticker(ticker).history(period=period)['Close'].iloc[-1]
options_data = download_options_data(ticker, nearest_date)
calls_data = options_data[options_data['contractSymbol'].str.contains('C')]
puts_data = options_data[options_data['contractSymbol'].str.contains('P')]

fig = create_plot(calls_data, puts_data, current_price, nearest_date)
fig.show()

#@title OPTIONS GRAPHS
import yfinance as yf
import pandas as pd
import plotly.express as px
from plotly.subplots import make_subplots
import os
from datetime import datetime, timedelta

# Set the ticker and desired date for options data
#ticker = 'NVDA'  # Replace 'AAPL' with your stock's ticker
myWeeks = 4
target_date = datetime.today() + timedelta(weeks=myWeeks)
period = "1d"  # You might need to define period for the current_price calculation

def download_options_data(ticker, date):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/options.{date}.{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        print(f"Options data for {ticker} found on disk.")
    except FileNotFoundError:
        # Download options data
        stock = yf.Ticker(ticker)
        options = stock.option_chain(date)
        df = pd.concat([options.calls, options.puts])
        df.to_csv(data_file)
        print(f"Options data for {ticker} downloaded and saved to disk.")
    return df

# Find the nearest options date and get current stock price
stock = yf.Ticker(ticker)
options_dates = stock.options
nearest_date = min(options_dates, key=lambda d: abs(datetime.strptime(d, "%Y-%m-%d") - target_date))
current_price = stock.history(period=period)['Close'].iloc[-1]

# Download data
options_data = download_options_data(ticker, nearest_date)

# Split the data into calls and puts
calls_data = options_data[options_data['contractSymbol'].str.contains('C')].copy()
puts_data = options_data[options_data['contractSymbol'].str.contains('P')].copy()

# Replace NaN values in 'volume' with a default size for both calls and puts
default_size_calls = calls_data['volume'].dropna().min()
default_size_puts = puts_data['volume'].dropna().min()
calls_data['volume'].fillna(default_size_calls, inplace=True)
puts_data['volume'].fillna(default_size_puts, inplace=True)


# Custom function to create subplots (instead of individual plots)
def create_subplot(fig, row, col, data, color_scale, title):
    fig.add_trace(
        px.scatter(data, x="strike", y="openInterest",
                   size="openInterest", color="openInterest",
                   opacity=0.8, color_continuous_scale=color_scale).data[0],
        row=row, col=col
    )

    fig.update_xaxes(title_text="Strike Price", showgrid=False, row=row, col=col)
    fig.update_yaxes(title_text="Open Interest", showgrid=False, row=row, col=col)
    fig.update_layout(
        plot_bgcolor='black', paper_bgcolor='black', font_color='white',
        title_text=f"{ticker} Options (Strike vs. Open Interest) - Current Price: ${current_price:.2f}",
        showlegend=False  # Optionally hide legends if they overlap
    )

# Create subplots figure
fig = make_subplots(rows=1, cols=2)  # 1 row, 2 columns for side-by-side

# Add the plots to the subplots
create_subplot(fig, 1, 1, calls_data, "Blues", "Call Options")
create_subplot(fig, 1, 2, puts_data, "Reds", "Put Options")

# Show the combined plot
fig.show()

#@title OPTIONS GRAPHS
import yfinance as yf
import pandas as pd
import plotly.express as px
from plotly.subplots import make_subplots
import os
from datetime import datetime, timedelta

# Set the ticker and desired date for options data
#ticker = 'NVDA'  # Replace 'AAPL' with your stock's ticker
myWeeks = 4
target_date = datetime.today() + timedelta(weeks=myWeeks)
period = "1d"  # You might need to define period for the current_price calculation

def download_options_data(ticker, date):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/options.{date}.{ticker}.csv"
    try:
        df = pd.read_csv(data_file)
        print(f"Options data for {ticker} found on disk.")
    except FileNotFoundError:
        # Download options data
        stock = yf.Ticker(ticker)
        options = stock.option_chain(date)
        df = pd.concat([options.calls, options.puts])
        df.to_csv(data_file)
        print(f"Options data for {ticker} downloaded and saved to disk.")
    return df

# Find the nearest options date and get current stock price
stock = yf.Ticker(ticker)
options_dates = stock.options
nearest_date = min(options_dates, key=lambda d: abs(datetime.strptime(d, "%Y-%m-%d") - target_date))
current_price = stock.history(period=period)['Close'].iloc[-1]

# Download data
options_data = download_options_data(ticker, nearest_date)

# Split the data into calls and puts
calls_data = options_data[options_data['contractSymbol'].str.contains('C')].copy()
puts_data = options_data[options_data['contractSymbol'].str.contains('P')].copy()

# Replace NaN values in 'volume' with a default size for both calls and puts
default_size_calls = calls_data['volume'].dropna().min()
default_size_puts = puts_data['volume'].dropna().min()
calls_data['volume'].fillna(default_size_calls, inplace=True)
puts_data['volume'].fillna(default_size_puts, inplace=True)

def create_subplot(fig, row, col, data, color, title):
    # Add the scatter plot
    fig.add_trace(
        px.scatter(data, x="strike", y="openInterest", size="openInterest", color="openInterest", opacity=0.8, color_continuous_scale=color).data[0],
        row=row, col=col
    )

    # Add the bars with see-through opacity
    fig.add_trace(
        px.bar(data, x="strike", y="openInterest", opacity=0.95, color_discrete_sequence=[color[-1]]).data[0],
        row=row, col=col
    )

    # Add the watermark annotation (adjust x position based on column)
    fig.add_annotation(
        text=title,
        xref="paper", yref="paper",
        x=0.25 if col == 1 else 0.75,  # Adjust x position for left/right plot
        y=0.5,
        showarrow=False,
        font=dict(
            family="Courier New, monospace",
            size=80,
            color=px.colors.sequential.Blues[0] if color == px.colors.sequential.Blues else px.colors.sequential.Reds[0],
        ),
        opacity=0.2,
    )

    # Update axes and layout
    fig.update_xaxes(title_text="Strike Price", showgrid=False, row=row, col=col)
    fig.update_yaxes(title_text="Open Interest", showgrid=False, row=row, col=col)
    fig.update_layout(
        plot_bgcolor='black',
        paper_bgcolor='black',
        font_color='white',
        title_text=f"{ticker} Options (Strike vs. Open Interest) - Current Price: ${current_price:.2f}",
        showlegend=False
    )

# Custom function to create subplots with watermarks and trend lines ORIG
def create_subplotORIG(fig, row, col, data, color, title):
    # Add the scatter plot
    fig.add_trace(
        px.scatter(data, x="strike", y="openInterest", size="openInterest", color="openInterest", opacity=0.8, color_continuous_scale=color).data[0],
        row=row, col=col
    )

    # Add the trend line
    fig.add_trace(
        px.line(data, x="strike", y="openInterest", color_discrete_sequence=[color[-1]]).data[0],
        row=row, col=col
    )

    # Add the watermark annotation (adjust x position based on column)
    fig.add_annotation(
        text=title,
        xref="paper", yref="paper",
        x=0.25 if col == 1 else 0.75,  # Adjust x position for left/right plot
        y=0.5,
        showarrow=False,
        font=dict(
            family="Courier New, monospace",
            size=80,
            color=px.colors.sequential.Blues[0] if color == px.colors.sequential.Blues else px.colors.sequential.Reds[0],
        ),
        opacity=0.2,
    )

    # Update axes and layout
    fig.update_xaxes(title_text="Strike Price", showgrid=False, row=row, col=col)
    fig.update_yaxes(title_text="Open Interest", showgrid=False, row=row, col=col)
    fig.update_layout(
        plot_bgcolor='black',
        paper_bgcolor='black',
        font_color='white',
        title_text=f"{ticker} Options (Strike vs. Open Interest) - Current Price: ${current_price:.2f}",
        showlegend=False
    )

# Create subplots figure
fig = make_subplots(rows=1, cols=2)

# Add plots with watermarks and trend lines
create_subplot(fig, 1, 1, calls_data, px.colors.sequential.Blues, "Calls")
create_subplot(fig, 1, 2, puts_data, px.colors.sequential.Reds, "Puts")

# Show the combined plot
fig.show()

#@title OPTIONS GRAPHS
import yfinance as yf
import pandas as pd
import plotly.express as px
from plotly.subplots import make_subplots
import os
from datetime import datetime, timedelta

# Set the ticker and desired date for options data
#ticker = 'NVDA'  # Replace 'AAPL' with your stock's ticker
myWeeks = 4
target_date = datetime.today() + timedelta(weeks=myWeeks)
period = "1d"  # You might need to define period for the current_price calculation

def download_options_data(ticker, date):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/options.{date}.{ticker}.csv"
    try:
        df = pd.read_csv(data_file)
        print(f"Options data for {ticker} found on disk.")
    except FileNotFoundError:
        # Download options data
        stock = yf.Ticker(ticker)
        options = stock.option_chain(date)
        df = pd.concat([options.calls, options.puts])
        df.to_csv(data_file)
        print(f"Options data for {ticker} downloaded and saved to disk.")
    return df

# Find the nearest options date and get current stock price
stock = yf.Ticker(ticker)
options_dates = stock.options
nearest_date = min(options_dates, key=lambda d: abs(datetime.strptime(d, "%Y-%m-%d") - target_date))
current_price = stock.history(period=period)['Close'].iloc[-1]

# Download data
options_data = download_options_data(ticker, nearest_date)

# Split the data into calls and puts
calls_data = options_data[options_data['contractSymbol'].str.contains('C')].copy()
puts_data = options_data[options_data['contractSymbol'].str.contains('P')].copy()

# Replace NaN values in 'volume' with a default size for both calls and puts
default_size_calls = calls_data['volume'].dropna().min()
default_size_puts = puts_data['volume'].dropna().min()
calls_data['volume'].fillna(default_size_calls, inplace=True)
puts_data['volume'].fillna(default_size_puts, inplace=True)

# Custom function to create subplots with watermarks and bars
def create_subplot(fig, row, col, data, color, title, flip_y=False):
    # Add the scatter plot
    fig.add_trace(
        px.scatter(data, x="strike", y="openInterest", size="openInterest", color="openInterest", opacity=0.8, color_continuous_scale=color).data[0],
        row=row, col=col
    )

    # Add the bars with see-through opacity
    fig.add_trace(
        px.bar(data, x="strike", y="openInterest", opacity=0.3, color_discrete_sequence=[color[-1]]).data[0],
        row=row, col=col
    )

    # Add the watermark annotation (adjust x position based on column)
    fig.add_annotation(
        text=title,
        xref="paper", yref="paper",
        x=0.25 if col == 1 else 0.75,  # Adjust x position for left/right plot
        y=0.5,
        showarrow=False,
        font=dict(
            family="Courier New, monospace",
            size=80,
            color=px.colors.sequential.Blues[0] if color == px.colors.sequential.Blues else px.colors.sequential.Reds[0],
        ),
        opacity=0.2,
    )

    # Update axes and layout
    fig.update_xaxes(title_text="Strike Price", showgrid=False, row=row, col=col)

    if flip_y:
        fig.update_yaxes(autorange="reversed", title_text="Open Interest", showgrid=False, row=row, col=col)
    else:
        fig.update_yaxes(title_text="Open Interest", showgrid=False, row=row, col=col)

    fig.update_layout(
        plot_bgcolor='black',
        paper_bgcolor='black',
        font_color='white',
        title_text=f"{ticker} Options (Strike vs. Open Interest) - Current Price: ${current_price:.2f}",
        showlegend=False
    )

# Create subplots figure
fig = make_subplots(rows=1, cols=2)

# Add plots with watermarks and bars
create_subplot(fig, 1, 1, calls_data, px.colors.sequential.Blues, "Calls", flip_y=True)
create_subplot(fig, 1, 2, puts_data, px.colors.sequential.Reds, "Puts", flip_y=True)

# Show the combined plot
fig.show()

#@title PUT/CALL Ratios
import yfinance as yf
import pandas as pd
import plotly.express as px
import os
from datetime import datetime, timedelta

# Set the ticker and desired date for options data
#ticker = 'AAPL'  # Replace 'AAPL' with your stock's ticker
#myWeeks=4 # defined in the options
target_date = datetime.today() + timedelta(weeks=myWeeks)

def download_options_data(ticker, date):
    today_str = datetime.today().strftime("%Y-%m-%d")
    data_dir = f"DATA/{today_str}/{ticker}"
    os.makedirs(data_dir, exist_ok=True)
    data_file = f"{data_dir}/options.{date}.{ticker}.csv"

    try:
        df = pd.read_csv(data_file)
        print(f"Options data for {ticker} found on disk.")
    except FileNotFoundError:
        # Download options data
        stock = yf.Ticker(ticker)
        options = stock.option_chain(date)
        df = pd.concat([options.calls, options.puts])
        df.to_csv(data_file)
        print(f"Options data for {ticker} downloaded and saved to disk.")
    return df

# Find the nearest options date and get current stock price
stock = yf.Ticker(ticker)
options_dates = stock.options
nearest_date = min(options_dates, key=lambda d: abs(datetime.strptime(d, "%Y-%m-%d") - target_date))

# Download data
options_data = download_options_data(ticker, nearest_date)

# Split the data into calls and puts
calls_data = options_data[options_data['contractSymbol'].str.contains('C')]
puts_data = options_data[options_data['contractSymbol'].str.contains('P')]

# Calculate put/call ratio for each strike price
combined_data = pd.merge(calls_data[['strike', 'openInterest']], puts_data[['strike', 'openInterest']], on='strike', suffixes=('_call', '_put'))
combined_data['put_call_ratio'] = combined_data['openInterest_put'] / combined_data['openInterest_call']
combined_data = combined_data.dropna()

# Plotting Put/Call Ratio
fig = px.bar(combined_data, x='strike', y='put_call_ratio', title='Put/Call Ratio by Strike Price')
fig.update_layout(xaxis_title='Strike Price', yaxis_title='Put/Call Ratio', plot_bgcolor='black', paper_bgcolor='black', font_color='white')
fig.show()

