# -*- coding: utf-8 -*-
"""ressurected.original.colorful.graphs.LRC.and.quadratic.regressions.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_1p3QZt8r7Ij6oBdo5ISot_Q3zovpmXD

The main thrust is currently to show Linear Regression Channel
Both for current stock, its percentage change, the same relative to its sector.
Later will show sharkfins
currently commented out
do both relative?
Need to add another function that will do all of the sectors and the rest
Need to add back in the relative comparison
1. do the second derivative chart
2. do the pdf maker for the full integrated image ?
3. the distance between the SMA's and the order, abdc
4. make sure that it runs as independent script to generate all the datas.
"""

#@title Run this to delete the folder of stocks
#!rm -rf stocks
#!rm -rf PNGS
#!ls stocks
#!mkdir PDFS
#!mv *.pdf ./PDFS/

#@title Enter the date in the following format:  1999-12-31
myStart='2022-01-01'#@param {type:'string'}
myEnd='2025-01-01'#@param {type:'string'}
#mode = "compareSingleStock" #@param ["dow", "sectors", "compareSingleStock", "compareMoonETFstocks", "compareArkETFs", "indices", "energy","grownCommodities","metals","debug","fins"]
stockName="tsla" #@param {type:'string'}
sectorName="QQQ" #@param {type:'string'}
equityType="Stock" #@param {type:'string'}
#singleComparison_IndexName="spy" #@param {type:'string'}
#allAtOnceGraph='yes' #@param ['no','yes']
#reportType = "fullIndex" #@param ["fullIndex", "singleStock"] {allow-input: true}
print("you entered :") # this is how we get cupy
print("startDate:"+myStart)
print("endDate:"+myEnd)
#!pip install yfinance


def checkPIP():
  try:
      import yfinance as yf
      import fpdf
      from PIL import Image
      from PIL.ExifTags import TAGS
      #import chainer
      #chainer.print_runtime_info()
      #warnings.simplefilter(action='ignore', category=FutureWarning)
      print(" yfinance installed ")

  except ModuleNotFoundError:
      #print("installing yfinance")
      #!pip install yfinance
      #!pip install cupy
      ##print("installing chainer")
     ## !curl https://colab.chainer.org/install | sh -
      print("install yfinance ")
      ##!pip install yfinance
      ##!pip install fpdf
      ##!pip install Pillow
      ##checkPIP()
checkPIP()

#!pip show scikit-learn

#!pip install openpyxl

#@title Import libraries and define global variables : double click here to modify


import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
import yfinance as yf
import sys
import datetime
import requests
import time
import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn import datasets, linear_model
from sklearn.metrics import mean_squared_error, r2_score
import openpyxl
import statsmodels.formula.api as smf
import statsmodels.formula.api as ols
from statsmodels.compat import lzip

#@title Functions for derivatives
def calcFirstDerivative(myDataframe):
  a=myDataframe[1:]
  b=myDataframe[:-1]
  a=a.reset_index()
  b=b.reset_index()
  c=b['Close']-a['Close']
  return c

def calcSecondDerivative(myDataframe):
  a=myDataframe[1:]
  b=myDataframe[:-1]
  a=a.reset_index()
  b=b.reset_index()
  c=b-a
  return c

#first=calcFirstDerivative(df['Close'])
#second=calcSecondDerivative(first)

#@title  revamped Local data download :
import sys,os
#Variables
stocksFolder='./stocks/'
imagesFolder='./PNGS/'
##plt.savefig(imagesFolder+stockName+myStart+'_'+myEnd+'.png')

stockFile=stocksFolder+stockName+'_'+myStart+'_'+myEnd+".csv"
sectorFile=stocksFolder+sectorName+'_'+myStart+'_'+myEnd+".csv"
qqqFile=stocksFolder+'qqq_'+myStart+'_'+myEnd+".csv"
goldFile=stocksFolder+'gold_'+myStart+'_'+myEnd+".csv"
spyFile=stocksFolder+'spy_'+myStart+'_'+myEnd+".csv"
iwmFile=stocksFolder+'iwm_'+myStart+'_'+myEnd+".csv"
eemFile=stocksFolder+'eem_'+myStart+'_'+myEnd+".csv"
tltFile=stocksFolder+'tlt_'+myStart+'_'+myEnd+".csv"
diaFile=stocksFolder+'dia_'+myStart+'_'+myEnd+".csv"

###sectorFile=stocksFolder+'_'+sectorName+".csv"
period='1d'

def makeRepo(folder):
  if not os.path.isdir(folder):
    try:
      os.makedirs(folder)
      print("created folder")
    except:
      print("problem creating directory:",folder)
  else:
      print("directory exists!",folder)


def downloadFile(tickerName,fileName,period):
  if not os.path.isfile(fileName):
    try:
      print("download the file:",fileName)
      downloadDF=yf.download(tickerName,start=myStart,end=myEnd,period=period)
      df=downloadDF
      df=df.reset_index()
      #order matters
      df['SMA30']=df['Close'].rolling(30).mean()
      df['SMA50']=df['Close'].rolling(50).mean()
      df['SMA100']=df['Close'].rolling(100).mean()
      df['SMA200']=df['Close'].rolling(200).mean()
      df['SMA300']=df['Close'].rolling(300).mean()
      df['SMA30PC']=df['SMA30'].pct_change()
      df['SMA50PC']=df['SMA50'].pct_change()
      df['SMA100PC']=df['SMA100'].pct_change()
      df['SMA200PC']=df['SMA200'].pct_change()
      df['ClosePC']=df['Close'].pct_change()
      df['VolumePC']=df['Volume'].pct_change()
      df['VolLOG'] = np.log2(df['Volume'])
      df['CloseLOG'] = np.log2(df['Close'])
      df['VLOGPC'] = df['VolLOG'].pct_change()
      df['CLOGPC'] = df['CloseLOG'].pct_change()
      #first=calcFirstDerivative(df['Close'])
      #second=calcSecondDerivative(first)
      #df['FIRSTDERIV']=first
      #df['SECONDDERIV']=second
      df.to_csv(fileName)
    except:
      print("Problem downloading:",tickerName)
  else:
    print("file exits!",fileName)

#trigger it:
makeRepo(stocksFolder)
makeRepo(imagesFolder)
downloadFile(stockName,stockFile,period)
downloadFile(sectorName,sectorFile,period)
downloadFile(sectorName,qqqFile,period)
downloadFile(sectorName,goldFile,period)
downloadFile(sectorName,spyFile,period)
downloadFile(sectorName,iwmFile,period)
downloadFile(sectorName,eemFile,period)
downloadFile(sectorName,tltFile,period)
downloadFile(sectorName,diaFile,period)

#@title make the image : maybe even remove this and just change the input into the function in the next block
import matplotlib.pyplot as plt
import pandas as pd
df=pd.read_csv(stockFile)

print(df.tail())

sns.set_style("white")
sns.set_context("notebook", font_scale=1.5, rc={"lines.linewidth": 2.5})

#only df where > 2*np.std(...?)
rp = sns.regplot(x=df.index, y='Close', data=df, ci=None, marker='.', color='lightblue', scatter_kws={'s':75})
zp = sns.regplot(x=df.index, y='Close', data=df, ci=None, marker='.', color='navy', scatter_kws={'s':5})

y_rp = rp.get_lines()[0].get_ydata()
x_rp = rp.get_lines()[0].get_xdata()
z_rp = rp.get_lines()[0].get_ydata()

def drawLines(deviations,color):
  for i in deviations:
    sns.lineplot(x=x_rp, y=y_rp + ( float(i)* np.std(y_rp)), color=myColor,linewidth=.5,linestyle='-')
    sns.lineplot(x=x_rp, y=y_rp - (float(i)* np.std(y_rp)), color=myColor,linewidth=.5,linestyle='-')

deviations=['.25','.5','.75','1','1.25','1.5','1.75']
myColor='lightgrey'
drawLines(deviations,myColor)
deviations=['1','2','3','4','5']
myColor='black'
drawLines(deviations,myColor)

smas=['SMA30','SMA50','SMA100','SMA200','SMA300']
smaColors=['g','orange','blue','purple','red']
for i in range(len(smas)):
  sns.lineplot(x=df.index,y=smas[i],data=df,color=smaColors[i],linewidth=1.6)

sns.set(rc={"figure.dpi":300, 'savefig.dpi':300})
plt.rc("figure", figsize=(16, 8))
plt.rc("font", size=14)
plt.title("LRC:  "+stockName.upper()+str(myStart)+"   to:"+str(myEnd))
plt.tick_params(axis='y', which='both', labelleft='off', labelright='on')
plt.savefig(imagesFolder+stockName+'_'+myStart+'_'+myEnd+'.png')

plt.show()

#@title : define lines to be drawn and colors This one has to happen

#  smas=['SMA30PC','SMA50PC','SMA100PC','SMA200PC','ClosePC','VolumePC']
#  smaColors=['g','orange','blue','purple','red','yellow']
if len(df)>201:
  myLines=['SMA30PC','SMA50PC','SMA100PC','SMA200PC']
  myColors=['g','orange','blue','purple']
  print("over 201")
elif len(df)>101:
  myLines=['SMA30PC','SMA50PC','SMA100PC']
  myColors=['g','orange','blue']
  print("over 201")
elif len(df)>51:
  myLines=['SMA30PC','SMA50PC']
  myColors=['g','orange']
  print("over 51")
elif len(df)>31:
  myLines=['SMA30PC']
  myColors=['g']
  print("over 31")

###@title see percentage graphs
####@title : plot regression channel
import matplotlib.pyplot as plt
import pandas as pd
sns.set_style("white")
sns.set_context("notebook", font_scale=1.5, rc={"lines.linewidth": 2.5})
#myRange='SMA30PC'
myRange=myLines[0]

#only df where > 2*np.std(...?)
rp = sns.regplot(x=df.index, y=myRange, data=df, ci=None, marker='.', color='lawngreen', scatter_kws={'s':75})
zp = sns.regplot(x=df.index, y=myRange, data=df, ci=None, marker='.', color='black', scatter_kws={'s':5})

y_rp = rp.get_lines()[0].get_ydata()
x_rp = rp.get_lines()[0].get_xdata()
z_rp = rp.get_lines()[0].get_ydata()

def printMyStats(myRange):
  #mystd=df['SMA30PC'].std()
  mystd=df[myRange].std()
  print('StandardDeviation ',myRange,' PercentageChange:',mystd)
  #mymean=df['SMA30PC'].mean()
  mymean=df[myRange].mean()
  print('Mean ',myRange,' PercentageChange:',mymean)
  print(df.tail(5))

printMyStats(myRange)

def drawLines(deviations,color):
  for i in deviations:
    sns.lineplot(x=x_rp, y=y_rp + ( float(i)* np.std(y_rp)), color=myColor,linewidth=.5,linestyle='-')
    sns.lineplot(x=x_rp, y=y_rp - (float(i)* np.std(y_rp)), color=myColor,linewidth=.5,linestyle='-')

deviations=['.25','.5','.75','1','1.25','1.5','1.75']
myColor='lightgrey'
drawLines(deviations,myColor)
deviations=['1','2','3','4','5']
myColor='black'
drawLines(deviations,myColor)

for i in range(len(smas)-1):
  sns.lineplot(x=df.index,y=myLines[i],data=df,color=myColors[i],linewidth=.6)

sns.set(rc={"figure.dpi":300, 'savefig.dpi':300})
plt.title("LRC: percentage graphs "+stockName.upper()+str(myStart)+"   to:"+str(myEnd))
plt.tick_params(axis='y', which='both', labelleft='off', labelright='on')
plt.savefig(imagesFolder+'movingAverages_percentages_'+stockName+'_'+myStart+'_'+myEnd+'.png')

plt.show()

###@title another try just for volume :
#myLines=['VLOGPC']
#myColors=['gold']
import matplotlib.pyplot as plt
import pandas as pd
sns.set_style("white")
sns.set_context("notebook", font_scale=1.5, rc={"lines.linewidth": 2.5})
myRange=myLines[0]

def printMyStats(myRange):
  mystd=df[myRange].std()
  print('StandardDeviation ',myRange,' PercentageChange:',mystd)
  mymean=df[myRange].mean()
  print('Mean ',myRange,' PercentageChange:',mymean)
  print(df.tail(5))
colName='VolLOG'
rp = sns.regplot(x=df.index, y=df[colName], data=df, ci=None, marker='.', color='lawngreen', scatter_kws={'s':75})
zp = sns.regplot(x=df.index, y=df[colName], data=df, ci=None, marker='.', color='black', scatter_kws={'s':5})
xp = sns.lineplot(x=df.index, y=df[colName], data=df, ci=None, marker='.', color='gold',linewidth=.4)

y_rp = rp.get_lines()[0].get_ydata()
x_rp = rp.get_lines()[0].get_xdata()
z_rp = rp.get_lines()[0].get_ydata()


def drawLines(deviations,color):
  for i in deviations:
    sns.lineplot(x=x_rp, y=y_rp + ( float(i)* np.std(y_rp)), color=myColor,linewidth=.5,linestyle='-')
    sns.lineplot(x=x_rp, y=y_rp - (float(i)* np.std(y_rp)), color=myColor,linewidth=.5,linestyle='-')

deviations=['.25','.5','.75','1','1.25','1.5','1.75']
myColor='lightgrey'
drawLines(deviations,myColor)
deviations=['1','2','3','4','5','10','20']
myColor='black'
drawLines(deviations,myColor)

#for i in range(len(smas)-1):
###sns.lineplot(x=df.index,y=myLines[0],data=df,color=myColors[0],linewidth=.6)

sns.set(rc={"figure.dpi":300, 'savefig.dpi':300})
plt.title("LRC: Volume LOG graphs "+stockName.upper()+str(myStart)+"   to:"+str(myEnd))
plt.tick_params(axis='y', which='both', labelleft='off', labelright='on')
plt.savefig(imagesFolder+'volumeLOG_graph_'+stockName+'_'+myStart+'_'+myEnd+'.png')

plt.show()


printMyStats(myRange)

###@title another try just for volume :
#myLines=['VLOGPC']
#myColors=['gold']
import matplotlib.pyplot as plt
import pandas as pd
sns.set_style("white")
sns.set_context("notebook", font_scale=1.5, rc={"lines.linewidth": 2.5})
#myRange=myLines[0]

def printMyStats(myRange):
  mystd=df[myRange].std()
  print('StandardDeviation ',myRange,' PercentageChange:',mystd)
  mymean=df[myRange].mean()
  print('Mean ',myRange,' PercentageChange:',mymean)
  print(df.tail(5))
colName='Close'
rp = sns.regplot(x=df.index, y=df[colName], data=df, ci=None, marker='.', color='gold', scatter_kws={'s':75})
zp = sns.regplot(x=df.index, y=df[colName], data=df, ci=None, marker='.', color='brown', scatter_kws={'s':5})
xp = sns.lineplot(x=df.index, y=df[colName], data=df, ci=None, marker='.', color='navy',linewidth=1)

y_rp = rp.get_lines()[0].get_ydata()
x_rp = rp.get_lines()[0].get_xdata()
z_rp = rp.get_lines()[0].get_ydata()


def drawLines(deviations,color):
  for i in deviations:
    sns.lineplot(x=x_rp, y=y_rp + ( float(i)* np.std(y_rp)), color=myColor,linewidth=.5,linestyle='-')
    sns.lineplot(x=x_rp, y=y_rp - (float(i)* np.std(y_rp)), color=myColor,linewidth=.5,linestyle='-')

deviations=['.25','.5','.75','1.25','1.5','1.75','2.25','2.5','2.75','3.25','3.5','3.75']
myColor='lightgrey'
drawLines(deviations,myColor)
deviations=['1','2','3','4']
myColor='black'
drawLines(deviations,myColor)

#for i in range(len(smas)-1):
###sns.lineplot(x=df.index,y=myLines[0],data=df,color=myColors[0],linewidth=.6)

sns.set(rc={"figure.dpi":300, 'savefig.dpi':300})
plt.title("LRC: "+colName+" graphs "+stockName.upper()+str(myStart)+"   to:"+str(myEnd))
plt.tick_params(axis='y', which='both', labelleft='off', labelright='on')
plt.savefig(imagesFolder+colName+'_graph_'+stockName+'_'+myStart+'_'+myEnd+'.png')

plt.show()


printMyStats(myRange)



# Commented out IPython magic to ensure Python compatibility.
def indentify_outliers(row, n_sigmas=3):
    '''
    # originally from the python for finance cookbook
    Function for identifying the outliers using the 3 sigma rule.
    The row must contain the following columns/indices: simple_rtn, mean, std.

    Parameters
    ----------
    row : pd.Series
        A row of a pd.DataFrame, over which the function can be applied.
    n_sigmas : int
        The number of standard deviations above/below the mean - used for detecting outliers

    Returns
    -------
    0/1 : int
        An integer with 1 indicating an outlier and 0 otherwise.
    '''
    x = row['simple_rtn']
    mu = row['mean']
    sigma = row['std']

    if (x > mu + 3 * sigma) | (x < mu - 3 * sigma):
        return 1
    else:
        return 0

import pandas as pd
import yfinance as yf
import math,sys,warnings
#import yfinance as yf
# %matplotlib inline
#%config InlineBackend.figure_format = 'retina'
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns
#plt.style.use('seaborn')
# plt.style.use('seaborn-colorblind') #alternative
# plt.rcParams['figure.figsize'] = [16, 9]
plt.rcParams['figure.dpi'] = 100
warnings.simplefilter(action='ignore', category=FutureWarning)
df=pd.read_csv(stockFile)
#stock='TQQQ'
#df = yf.download(stock,
#                 start='2020-01-01',
#                 #start='2020-12-1',
#                 end='2021-12-31',
#                 progress=False)
#massage dataframe

df = df.loc[:, ['Adj Close']]
df.rename(columns={'Adj Close':'adj_close'}, inplace=True)
df['simple_rtn'] = df.adj_close.pct_change()
df.head()
df_rolling = df[['simple_rtn']].rolling(window=21).agg(['mean', 'std'])
df_rolling.columns = df_rolling.columns.droplevel()
df_outliers = df.join(df_rolling)
df_outliers['outlier'] = df_outliers.apply(indentify_outliers,axis=1)
outliers = df_outliers.loc[df_outliers['outlier'] == 1,['simple_rtn']]


def showThreeSD():
  fig, ax = plt.subplots()
  ax.plot(df_outliers.index, df_outliers.simple_rtn, color='blue', label='Normal')
  ax.scatter(outliers.index, outliers.simple_rtn, color='red', label='Anomaly')
  ax.set_title(stockName+" 2020 (3xstd.dev) stock price moves this period==>"+ str(outliers.simple_rtn.count()))
  ax.legend(loc='lower right')
  #graph of outliers :
  plt.savefig(imagesFolder+'3_standard_deviations_graph_'+stockName+'_'+myStart+'_'+myEnd+'.png')

  plt.show(fig)

showThreeSD()
#df.to_csv('testout2.csv')
#!cp testout2.csv "/content/drive/"

## consecutive up down days :
# i want to take the simple return and see . convert to how many concurrent days up or down
df2=df['simple_rtn'].copy(deep=True)
df2[df2>0]=1
df2[df2<0]=-1
df3=df2.copy(deep=True)
#ax2.plot(df['simple_rtn'],color='green', label='Normal')

#old=0
tally=1
old=1
runningSum=0
for value in df3:
  if ( math.isnan(value)):
      print(" skipping a nan ")
  else:
    combined=int(old)+int(value)
    if( combined == 0 ) :
      mesg="PN"
      #print("one poz one neg ")
      runningSum=0
    elif( combined < 0 ) :
      mesg="2N"
      #print ( " two negs ")
      runningSum=runningSum-1
    elif ( combined > 0 ):
      mesg="2P"
      #print ( " two poz")
      runningSum=runningSum+1
    tally=tally+1
    old=value
    #for debugging
    ##print("check : "+mesg+" iteration:"+str(tally)+" runningSum:"+str(runningSum))
    #print(df3.head())
    ## This is a modification to see what happens when I zero anything under 2 ? and above -2 ?
    #   it does not seem to work yet
    #if(runningSum<=2 & runningSum>=-2):

    df3.iloc[tally-1]=runningSum

def showUpDownDays():
  #do the stats for the history of the stock
  totalDays=df3.count()
  print("UP/Down Consecutive Trading Days out of a Total of :"+str(totalDays)+" Days for StockName:"+stockName)
  for i in range(0,int(df3.max()),1):
    myDays=df3[(df3==i)|(df3==-i)].count()
    print(str(i)+"   [[  "+str(myDays)+"  ]]   ,  "+str((100*((myDays/totalDays))).round(2))+"%")
  #print("Total trading days:",df3.count())
  #print("Up/Down 1 day",df3[(df3==1)|(df3==-1)].count())
  print(" ************************************************* ")
  print("Last five trading days:",df3.tail(5))
  print("come back later and turn this guy into a data frame ")
## show the text up down
showUpDownDays()

def showConsecutiveDays():
  #do zeroing out ?
  ###df3[(df3<5)&(df3>-5)]=0
  df3[(df3<3)&(df3>-3)]=0
  fig2, ax2 = plt.subplots()
  ax2.plot(df3,color='green', label='Normal')
  #ax2.scatter(outliers.index, outliers.simple_rtn, color='red', label='Anomaly')
  ax2.set_title(stockName+" simple return :"+ str(stockName))
  ax2.legend(loc='lower right')
  plt.savefig(imagesFolder+'consecutive_up_down_days_graph_'+stockName+'_'+myStart+'_'+myEnd+'.png')

  plt.show(fig2)
  ##tally some stats : 5 days up, 6 days up , 7 days up, 8 days up, over 8
  ##five=df3[df3==5].count()
  ##print("tally of five consecutive days : "+str(five))
  #print("consecutive days last two trading days: ",df3.tail(2))
  #print("consecutive days up the previous trading day",df3.tail(:,-1))

showConsecutiveDays()

import scipy.stats as scs
import statsmodels.api as sm
sns.set_style("white")
sns.set_context("notebook", font_scale=1.5, rc={"lines.linewidth": 2.5})
df=pd.read_csv(stockFile)
df = df[['Adj Close']].rename(columns={'Adj Close': 'adj_close'})
df['log_rtn'] = np.log(df.adj_close/df.adj_close.shift(1))
df = df[['adj_close', 'log_rtn']].dropna(how = 'any')
r_range = np.linspace(min(df.log_rtn), max(df.log_rtn), num=1000)
mu = df.log_rtn.mean()
sigma = df.log_rtn.std()
norm_pdf = scs.norm.pdf(r_range, loc=mu, scale=sigma)
fig, ax = plt.subplots(1, 2, figsize=(16, 8))

# histogram
sns.distplot(df.log_rtn, kde=False, norm_hist=True, ax=ax[0])
ax[0].set_title('Distribution of '+stockName+' returns', fontsize=16)
ax[0].plot(r_range, norm_pdf, 'g', lw=2,
           label=f'N({mu:.2f}, {sigma**2:.4f})')
ax[0].legend(loc='upper left');

# Q-Q plot
qq = sm.qqplot(df.log_rtn.values, line='s', ax=ax[1])
ax[1].set_title('Q-Q plot', fontsize = 16)
plt.savefig(imagesFolder+'distribution_and_qqplot_'+stockName+'_'+myStart+'_'+myEnd+'.png')

# plt.tight_layout()
# plt.savefig('images/ch1_im10.png')
plt.show()

###@title another try just for volume :
#myLines=['VLOGPC']
#myColors=['gold']
import matplotlib.pyplot as plt
import pandas as pd
df=pd.read_csv(stockFile)
sns.set_style("white")
sns.set_context("notebook", font_scale=1.5, rc={"lines.linewidth": 2.5})
#myRange=myLines[0]
first=calcFirstDerivative(df['Close'])
second=calcSecondDerivative(first)
df['Close']=first
print(first.head())
print(second.head())

def printMyStats(myRange):
  mystd=df[myRange].std()
  print('StandardDeviation ',myRange,' PercentageChange:',mystd)
  mymean=df[myRange].mean()
  print('Mean ',myRange,' PercentageChange:',mymean)
  print(df.tail(5))

colName='Close'
#modified for the derivatives:
rp = sns.regplot(x=df.index, y=df[colName], data=df, ci=None, marker='.', color='gold', scatter_kws={'s':75})
zp = sns.regplot(x=df.index, y=df[colName], data=df, ci=None, marker='.', color='brown', scatter_kws={'s':5})
xp = sns.lineplot(x=df.index, y=df[colName], data=df, ci=None, marker='.', color='navy',linewidth=1)

y_rp = rp.get_lines()[0].get_ydata()
x_rp = rp.get_lines()[0].get_xdata()
z_rp = rp.get_lines()[0].get_ydata()


def drawLines(deviations,color):
  for i in deviations:
    sns.lineplot(x=x_rp, y=y_rp + ( float(i)* np.std(y_rp)), color=myColor,linewidth=.5,linestyle='-')
    sns.lineplot(x=x_rp, y=y_rp - (float(i)* np.std(y_rp)), color=myColor,linewidth=.5,linestyle='-')

deviations=['.25','.5','.75','1.25','1.5','1.75','2.25','2.5','2.75','3.25','3.5','3.75']
myColor='lightgrey'
drawLines(deviations,myColor)
deviations=['1','2','3','4']
myColor='black'
drawLines(deviations,myColor)

#for i in range(len(smas)-1):
###sns.lineplot(x=df.index,y=myLines[0],data=df,color=myColors[0],linewidth=.6)
colName='first derivative'
sns.set(rc={"figure.dpi":300, 'savefig.dpi':300})
plt.title("LRC: "+colName+" graphs "+stockName.upper()+str(myStart)+"   to:"+str(myEnd))
plt.tick_params(axis='y', which='both', labelleft='off', labelright='on')
plt.savefig(imagesFolder+colName+'_graph_'+stockName+'_'+myStart+'_'+myEnd+'.png')

plt.show()


#printMyStats(df['Close'])

first=calcFirstDerivative(df['Close'])
second=calcSecondDerivative(first)
print("first derivative:")
print(first.tail())
print("second derivative:")
print(second.tail())

###@title see percentage graphs  This is the functionized version :
def fullThing(graphName,myLines,myColors,myRange):

  def printMyStats(myRange):
    mystd=df[myRange].std()
    print('StandardDeviation ',myRange,' PercentageChange:',mystd)
    mymean=df[myRange].mean()
    print('Mean ',myRange,' PercentageChange:',mymean)
    print(df.tail(5))


  def drawLines(deviations,color,x_rp,y_rp):
    sns.set_style("white")
    sns.set_context("notebook", font_scale=1.5, rc={"lines.linewidth": 2.5})
    for i in deviations:
      sns.lineplot(x=x_rp, y=y_rp + ( float(i)* np.std(y_rp)), color=myColor,linewidth=.5,linestyle='-')
      sns.lineplot(x=x_rp, y=y_rp - (float(i)* np.std(y_rp)), color=myColor,linewidth=.5,linestyle='-')

  def plotLRC(myLines,myColors,myRange):
    import matplotlib.pyplot as plt
    import pandas as pd
    rp = sns.regplot(x=df.index, y=myRange, data=df, ci=None, marker='.', color='lawngreen', scatter_kws={'s':75})
    zp = sns.regplot(x=df.index, y=myRange, data=df, ci=None, marker='.', color='black', scatter_kws={'s':5})
    y_rp = rp.get_lines()[0].get_ydata()
    x_rp = rp.get_lines()[0].get_xdata()
    z_rp = rp.get_lines()[0].get_ydata()
    deviations=['.25','.5','.75','1','1.25','1.5','1.75']
    myColor='lightgrey'
    drawLines(deviations,myColor,x_rp,y_rp)
    deviations=['1','2','3','4','5']
    myColor='black'
    drawLines(deviations,myColor,x_rp,y_rp)



  #Trigger the lines
  plotLRC(myLines,myColors,myRange)
  '''
  deviations=['.25','.5','.75','1','1.25','1.5','1.75']
  myColor='lightgrey'
  drawLines(deviations,myColor)
  deviations=['1','2','3','4','5']
  myColor='black'
  drawLines(deviations,myColor)
  '''
  for i in range(len(myLines)):
    sns.lineplot(x=df.index,y=myLines[i],data=df,color=myColors[i],linewidth=.6)

  sns.set(rc={"figure.dpi":300, 'savefig.dpi':300})
  sns.set_style("white")
  sns.set_context("notebook", font_scale=1.5, rc={"lines.linewidth": 2.5})
  plt.title("LRC: "+graphName+"  "+stockName.upper()+str(myStart)+"   to:"+str(myEnd))
  plt.tick_params(axis='y', which='both', labelleft='off', labelright='on')
  plt.savefig(imagesFolder+graphName+'_'+stockName+'_'+myStart+'_'+myEnd+'.png')

  plt.show()

  printMyStats(myRange)
#main
#percentage change SMAs graph
graphName='percentChange_movingAverages'
#fullThing(graphName,myLines,myColors)
#graphName='percentChange_closingPrice'
# close percentage change graph
myLines=['ClosePC']
myColors=['lightblue']
myRange=myLines[0]
fullThing(graphName,myLines,myColors,myRange)

## should run through and do a separate one for Volume and price close?

###@title : download data
import sys,os
plt.rc("figure", figsize=(16, 8))
plt.rc("font", size=14)

outFolder='./stocks/'
myPath=outFolder
if not os.path.isdir(myPath):
  try:
    os.makedirs(myPath)
  except:
    print("problem creating directory:",myPath)

#print if i am going to check it lives there
# i need to download into files and reimport into pandas from there
from datetime import datetime
#print("started---->"+str(datetime.now()))
startTS=datetime.timestamp(datetime.now())
#print("timestamp--->"+str(startTS))
dfStock=yf.download(stockName,start=myStart,end=myEnd,period='1d')
dfSector=yf.download(sectorName,start=myStart,end=myEnd,period='1d')
#df=dfb/dfa
###df=dfStock/dfSector
df=dfStock
### now make the part that is the graph part into a function to reuse
####df=dfa
#print(df.head())
df=df.reset_index()
#print(df.head())

#print("Finished---->"+str(datetime.now()))
endTS=datetime.timestamp(datetime.now())
#print("total RunTime--->"+str(endTS-startTS))

####@title : plot regression channel
import matplotlib.pyplot as plt
import pandas as pd
sns.set_style("white")
sns.set_context("notebook", font_scale=1.5, rc={"lines.linewidth": 2.5})

#only df where > 2*np.std(...?)
rp = sns.regplot(x=df.index, y='Close', data=df, ci=None, marker='.', color='lightblue', scatter_kws={'s':75})
zp = sns.regplot(x=df.index, y='Close', data=df, ci=None, marker='.', color='navy', scatter_kws={'s':5})

#####usingi numpy works
#####rp = sns.regplot(x=X1, y=Y1, ci=None, color='green')

y_rp = rp.get_lines()[0].get_ydata()
x_rp = rp.get_lines()[0].get_xdata()
z_rp = rp.get_lines()[0].get_ydata()

print("STDDEV:")
mystd=df['Close'].std()
print("MEAN:")
mymean=df['Close'].mean()
print("##### data ####")
print(mymean)
print(" std: ",mystd," mean:",mymean)
print(df['Close'][df['Close']>df['Close'].std()].count())
print(df.tail(5))
#deviations=['.5','1','1.25','1.5','1.75','2','3','4']
#devColors=['grey','grey','grey','grey','blue','green','red']
#count=0
def drawLines(deviations,color):
  for i in deviations:
    sns.lineplot(x=x_rp, y=y_rp + ( float(i)* np.std(y_rp)), color=myColor,linewidth=.5,linestyle='-')
    sns.lineplot(x=x_rp, y=y_rp - (float(i)* np.std(y_rp)), color=myColor,linewidth=.5,linestyle='-')
    #sns.lineplot(x=x_rp, y=y_rp + ( float(i)* np.std(y_rp)), color='lightgrey',linewidth=.5,linestyle='-')
    #sns.lineplot(x=x_rp, y=y_rp - (float(i)* np.std(y_rp)), color='lightgrey',linewidth=.5,linestyle='-')

deviations=['.25','.5','.75','1','1.25','1.5','1.75']
myColor='lightgrey'
drawLines(deviations,myColor)
deviations=['1','2','3','4','5']
myColor='black'
drawLines(deviations,myColor)


df['SMA30']=df['Close'].rolling(30).mean()
df['SMA50']=df['Close'].rolling(50).mean()
df['SMA100']=df['Close'].rolling(100).mean()
df['SMA200']=df['Close'].rolling(200).mean()
df['SMA300']=df['Close'].rolling(300).mean()
smas=['SMA30','SMA50','SMA100','SMA200','SMA300']
smaColors=['g','orange','blue','purple','red']
for i in range(len(smas)):
  sns.lineplot(x=df.index,y=smas[i],data=df,color=smaColors[i],linewidth=1.6)

sns.set(rc={"figure.dpi":300, 'savefig.dpi':300})
#plt.rcParams['figure.dpi'] = 300
#plt.rcParams['savefig.dpi'] = 300
#plt.legend(handles=smas)
#[eight, nine])
#@plt.legend(title='Simple Moving Averages  ', loc='center left', labels=['30','60','100','200'],bbox_to_anchor=(.5, -.2),
#          fancybox=True, shadow=True, ncol=5,color=smaColors)
###plt.title("LRC:  "+stockName.upper()+" relative to QQQ    from:"+str(myStart)+"   to:"+str(myEnd))
plt.title("LRC:  "+stockName.upper()+str(myStart)+"   to:"+str(myEnd))


plt.tick_params(axis='y', which='both', labelleft='off', labelright='on')
###plt.yaxis.tick_right()
#plt.title("LRC: "+stockName.upper()+"   from:"+str(myStart)+"   to:"+str(myEnd))
#plt.savefig(stockName+'relative_to_qqq_'+myStart+'_'+myEnd+'.png')
plt.savefig(stockName+myStart+'_'+myEnd+'.png')

plt.show()

# Commented out IPython magic to ensure Python compatibility.
# Import necessary libraries at the top
import numpy as np
import matplotlib.pyplot as plt
from numpy.fft import fft

# Ensure plots show in Jupyter notebooks
# %matplotlib inline

# Function definition
def myFitter(polyLevel, myFrame, myName):
    """
    This function takes a dataframe and returns
    quadratic fit and plot
    """
    print(myName + ". was passed")
    new = myFrame.to_numpy()
    x = range(len(myFrame))
    print(list(x))  # Print the range as a list for clarity

    # Poly model
    model = np.poly1d(np.polyfit(x, new, polyLevel))
    line = np.linspace(1, len(df), 100)

    # Plotting
    plt.figure()
    plt.title(stockName + " from: " + myStart + " to " + myEnd)
    plt.scatter(x, new)
    plt.plot(line, model(line))
    plt.show()

    # Print model details
    print("The model is: " + str(model) + "\nFirst derivative: " + str(np.polyder(model)))
    print("Second derivative: " + str(np.polyder(model, 2)))
    print("Roots: " + str(np.roots(np.polyder(model, 2))))

    # FFT
    X = fft(new)
    N = len(X)
    n = np.arange(N)
    T = N / 2
    freq = n / T

    # Plotting FFT
    plt.figure()
    plt.stem(freq, np.abs(X), 'b', markerfmt=" ", basefmt="-b")
    plt.show()

# Check if 'percentChange' column exists, if not create it
if 'percentChange' not in df.columns:
    df['percentChange'] = df['Close'].pct_change()  # Create the 'percentChange' column
    df = df.dropna(subset=['percentChange'])  # Drop rows with NaN values in 'percentChange'

# Running the fitting and plotting
print("This can be used to see when you would optimally buy call or put")
fitLevel = 3
myFitter(fitLevel, df['Close'], "Actual values were passed: " + str(fitLevel) + "\n")
myFitter(fitLevel, df['percentChange'], "Percentage: " + str(fitLevel) + "\n")

fitLevel = 1
print("This first image is the slope of the stock's price action")
myFitter(fitLevel, df['Close'], "Actual values were passed: " + str(fitLevel) + "\n")

print("This is the slope of the percentage change in the stock")
myFitter(fitLevel, df['percentChange'], "Percentage: " + str(fitLevel) + "\n")

#make pdfs :
#0,0,210,297
import os
from PIL import Image
from PIL.ExifTags import TAGS
path=imagesFolder
from fpdf import FPDF
pdf = FPDF()
#imagelist = [item for item in items if isfile(join(imagesFolder, item))]
imagelist = [f for f in os.listdir(path) if os.path.isfile( os.path.join(path, f) )]
# imagelist is the list with all image filenames
pdf = FPDF("L", unit = "pt", format = "legal")
for image in imagelist:
    imagename=path+image
    print("processing:"+imagename)
    #image = Image.open(imagename)
    #h=image.height
    #w=image.width
    #h=2400
    #w=4800
    #print("Image HxW=",h,w)
    pdf.add_page()
    pdf.image(imagename, 0, 0, 0, 525)
    #pdf.add_page()
    #pdf.image(path+image)
    #pdf.image(imagename,0,0,h,w)
    #pdf.image(image,x,y,w,h)
pdf.output(stockName+"_"+myStart+"_"+myEnd+".pdf", "F")
print("finished creating pdf")





